{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ResourceTextEdit } from '../../../browser/services/bulkEditService.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\n/**\n * Given a {@link DropOrPasteEdit} and set of ranges, creates a {@link WorkspaceEdit} that applies the insert text from\n * the {@link DropOrPasteEdit} at each range plus any additional edits.\n */\nexport function createCombinedWorkspaceEdit(uri, ranges, edit) {\n  // If the edit insert text is empty, skip applying at each range\n  if (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {\n    return {\n      edits: edit.additionalEdit?.edits ?? []\n    };\n  }\n  return {\n    edits: [...ranges.map(range => new ResourceTextEdit(uri, {\n      range,\n      text: typeof edit.insertText === 'string' ? SnippetParser.escape(edit.insertText) + '$0' : edit.insertText.snippet,\n      insertAsSnippet: true\n    })), ...(edit.additionalEdit?.edits ?? [])]\n  };\n}\nexport function sortEditsByYieldTo(edits) {\n  function yieldsTo(yTo, other) {\n    if ('mimeType' in yTo) {\n      return yTo.mimeType === other.handledMimeType;\n    }\n    return !!other.kind && yTo.kind.contains(other.kind);\n  }\n  // Build list of nodes each node yields to\n  const yieldsToMap = new Map();\n  for (const edit of edits) {\n    for (const yTo of edit.yieldTo ?? []) {\n      for (const other of edits) {\n        if (other === edit) {\n          continue;\n        }\n        if (yieldsTo(yTo, other)) {\n          let arr = yieldsToMap.get(edit);\n          if (!arr) {\n            arr = [];\n            yieldsToMap.set(edit, arr);\n          }\n          arr.push(other);\n        }\n      }\n    }\n  }\n  if (!yieldsToMap.size) {\n    return Array.from(edits);\n  }\n  // Topological sort\n  const visited = new Set();\n  const tempStack = [];\n  function visit(nodes) {\n    if (!nodes.length) {\n      return [];\n    }\n    const node = nodes[0];\n    if (tempStack.includes(node)) {\n      console.warn('Yield to cycle detected', node);\n      return nodes;\n    }\n    if (visited.has(node)) {\n      return visit(nodes.slice(1));\n    }\n    let pre = [];\n    const yTo = yieldsToMap.get(node);\n    if (yTo) {\n      tempStack.push(node);\n      pre = visit(yTo);\n      tempStack.pop();\n    }\n    visited.add(node);\n    return [...pre, node, ...visit(nodes.slice(1))];\n  }\n  return visit(Array.from(edits));\n}","map":{"version":3,"names":["ResourceTextEdit","SnippetParser","createCombinedWorkspaceEdit","uri","ranges","edit","insertText","snippet","edits","additionalEdit","map","range","text","escape","insertAsSnippet","sortEditsByYieldTo","yieldsTo","yTo","other","mimeType","handledMimeType","kind","contains","yieldsToMap","Map","yieldTo","arr","get","set","push","size","Array","from","visited","Set","tempStack","visit","nodes","length","node","includes","console","warn","has","slice","pre","pop","add"],"sources":["P:/IDEA/JudgeX/judgex_front/node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/edit.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ResourceTextEdit } from '../../../browser/services/bulkEditService.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\n/**\n * Given a {@link DropOrPasteEdit} and set of ranges, creates a {@link WorkspaceEdit} that applies the insert text from\n * the {@link DropOrPasteEdit} at each range plus any additional edits.\n */\nexport function createCombinedWorkspaceEdit(uri, ranges, edit) {\n    // If the edit insert text is empty, skip applying at each range\n    if (typeof edit.insertText === 'string' ? edit.insertText === '' : edit.insertText.snippet === '') {\n        return {\n            edits: edit.additionalEdit?.edits ?? []\n        };\n    }\n    return {\n        edits: [\n            ...ranges.map(range => new ResourceTextEdit(uri, { range, text: typeof edit.insertText === 'string' ? SnippetParser.escape(edit.insertText) + '$0' : edit.insertText.snippet, insertAsSnippet: true })),\n            ...(edit.additionalEdit?.edits ?? [])\n        ]\n    };\n}\nexport function sortEditsByYieldTo(edits) {\n    function yieldsTo(yTo, other) {\n        if ('mimeType' in yTo) {\n            return yTo.mimeType === other.handledMimeType;\n        }\n        return !!other.kind && yTo.kind.contains(other.kind);\n    }\n    // Build list of nodes each node yields to\n    const yieldsToMap = new Map();\n    for (const edit of edits) {\n        for (const yTo of edit.yieldTo ?? []) {\n            for (const other of edits) {\n                if (other === edit) {\n                    continue;\n                }\n                if (yieldsTo(yTo, other)) {\n                    let arr = yieldsToMap.get(edit);\n                    if (!arr) {\n                        arr = [];\n                        yieldsToMap.set(edit, arr);\n                    }\n                    arr.push(other);\n                }\n            }\n        }\n    }\n    if (!yieldsToMap.size) {\n        return Array.from(edits);\n    }\n    // Topological sort\n    const visited = new Set();\n    const tempStack = [];\n    function visit(nodes) {\n        if (!nodes.length) {\n            return [];\n        }\n        const node = nodes[0];\n        if (tempStack.includes(node)) {\n            console.warn('Yield to cycle detected', node);\n            return nodes;\n        }\n        if (visited.has(node)) {\n            return visit(nodes.slice(1));\n        }\n        let pre = [];\n        const yTo = yieldsToMap.get(node);\n        if (yTo) {\n            tempStack.push(node);\n            pre = visit(yTo);\n            tempStack.pop();\n        }\n        visited.add(node);\n        return [...pre, node, ...visit(nodes.slice(1))];\n    }\n    return visit(Array.from(edits));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}