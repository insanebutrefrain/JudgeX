{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { defineComponent, toRefs, ref, computed, watch, nextTick, onMounted, onUnmounted, createVNode } from \"vue\";\nimport { getTabListStyle, updateScrollOffset } from \"./utils.js\";\nimport { getPrefixCls } from \"../_utils/global-config.js\";\nimport TabsTab from \"./tabs-tab.js\";\nimport TabsButton from \"./tabs-button.js\";\nimport TabsNavInk from \"./tabs-nav-ink.js\";\nimport IconHover from \"../_components/icon-hover.js\";\nimport IconPlus from \"../icon/icon-plus/index.js\";\nimport ResizeObserver from \"../_components/resize-observer.js\";\nimport { isUndefined, isNumber } from \"../_utils/is.js\";\nimport { on, off } from \"../_utils/dom.js\";\nvar TabsNav = defineComponent({\n  name: \"TabsNav\",\n  props: {\n    tabs: {\n      type: Array,\n      required: true\n    },\n    direction: {\n      type: String,\n      required: true\n    },\n    type: {\n      type: String,\n      required: true\n    },\n    activeKey: {\n      type: [String, Number]\n    },\n    activeIndex: {\n      type: Number,\n      required: true\n    },\n    position: {\n      type: String,\n      required: true\n    },\n    size: {\n      type: String,\n      required: true\n    },\n    showAddButton: {\n      type: Boolean,\n      default: false\n    },\n    editable: {\n      type: Boolean,\n      default: false\n    },\n    animation: {\n      type: Boolean,\n      required: true\n    },\n    headerPadding: {\n      type: Boolean,\n      default: true\n    },\n    scrollPosition: {\n      type: String,\n      default: \"auto\"\n    }\n  },\n  emits: [\"click\", \"add\", \"delete\"],\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const {\n      tabs,\n      activeKey,\n      activeIndex,\n      direction,\n      scrollPosition\n    } = toRefs(props);\n    const prefixCls = getPrefixCls(\"tabs-nav\");\n    const wrapperRef = ref();\n    const listRef = ref();\n    const tabsRef = ref({});\n    const activeTabRef = computed(() => {\n      if (!isUndefined(activeKey.value)) {\n        return tabsRef.value[activeKey.value];\n      }\n      return void 0;\n    });\n    const inkRef = ref();\n    const mergedEditable = computed(() => props.editable && [\"line\", \"card\", \"card-gutter\"].includes(props.type));\n    const isScroll = ref(false);\n    const wrapperLength = ref(0);\n    const maxOffset = ref(0);\n    const offset = ref(0);\n    const getWrapperLength = () => {\n      var _a, _b, _c;\n      return (_c = direction.value === \"vertical\" ? (_a = wrapperRef.value) == null ? void 0 : _a.offsetHeight : (_b = wrapperRef.value) == null ? void 0 : _b.offsetWidth) != null ? _c : 0;\n    };\n    const getMaxOffset = () => {\n      if (!listRef.value || !wrapperRef.value) {\n        return 0;\n      }\n      if (direction.value === \"vertical\") {\n        return listRef.value.offsetHeight - wrapperRef.value.offsetHeight;\n      }\n      return listRef.value.offsetWidth - wrapperRef.value.offsetWidth;\n    };\n    const getSize = () => {\n      isScroll.value = isOverflow();\n      if (isScroll.value) {\n        wrapperLength.value = getWrapperLength();\n        maxOffset.value = getMaxOffset();\n        if (offset.value > maxOffset.value) {\n          offset.value = maxOffset.value;\n        }\n      } else {\n        offset.value = 0;\n      }\n    };\n    const isOverflow = () => {\n      if (wrapperRef.value && listRef.value) {\n        return props.direction === \"vertical\" ? listRef.value.offsetHeight > wrapperRef.value.offsetHeight : listRef.value.offsetWidth > wrapperRef.value.offsetWidth;\n      }\n      return false;\n    };\n    const setOffset = newOffset => {\n      if (!wrapperRef.value || !listRef.value || newOffset < 0) {\n        newOffset = 0;\n      }\n      offset.value = Math.min(newOffset, maxOffset.value);\n    };\n    const setActiveTabOffset = () => {\n      if (!activeTabRef.value || !wrapperRef.value || !isScroll.value) return;\n      updateScrollOffset(wrapperRef.value, direction.value);\n      const isHorizontal = direction.value === \"horizontal\";\n      const offsetProperty = isHorizontal ? \"offsetLeft\" : \"offsetTop\";\n      const sizeProperty = isHorizontal ? \"offsetWidth\" : \"offsetHeight\";\n      const tabOffset = activeTabRef.value[offsetProperty];\n      const tabSize = activeTabRef.value[sizeProperty];\n      const wrapperSize = wrapperRef.value[sizeProperty];\n      const tabStyle = window.getComputedStyle(activeTabRef.value);\n      const marginProperty = isHorizontal ? scrollPosition.value === \"end\" ? \"marginRight\" : \"marginLeft\" : scrollPosition.value === \"end\" ? \"marginBottom\" : \"marginTop\";\n      const tabMargin = parseFloat(tabStyle[marginProperty]) || 0;\n      if (scrollPosition.value === \"auto\") {\n        if (tabOffset < offset.value) {\n          setOffset(tabOffset - tabMargin);\n        } else if (tabOffset + tabSize > offset.value + wrapperSize) {\n          setOffset(tabOffset + tabSize - wrapperSize + tabMargin);\n        }\n      } else if (scrollPosition.value === \"center\") {\n        setOffset(tabOffset + (tabSize - wrapperSize + tabMargin) / 2);\n      } else if (scrollPosition.value === \"start\") {\n        setOffset(tabOffset - tabMargin);\n      } else if (scrollPosition.value === \"end\") {\n        setOffset(tabOffset + tabSize - wrapperSize + tabMargin);\n      } else if (isNumber(scrollPosition.value)) {\n        setOffset(tabOffset - scrollPosition.value);\n      }\n    };\n    const handleWheel = ev => {\n      if (!isScroll.value) return;\n      ev.preventDefault();\n      const {\n        deltaX,\n        deltaY\n      } = ev;\n      if (Math.abs(deltaX) > Math.abs(deltaY)) {\n        setOffset(offset.value + deltaX);\n      } else {\n        setOffset(offset.value + deltaY);\n      }\n    };\n    const handleClick = (key, ev) => {\n      emit(\"click\", key, ev);\n    };\n    const handleDelete = (key, ev) => {\n      emit(\"delete\", key, ev);\n      nextTick(() => {\n        delete tabsRef.value[key];\n      });\n    };\n    const handleButtonClick = type => {\n      const nextOffset = type === \"previous\" ? offset.value - wrapperLength.value : offset.value + wrapperLength.value;\n      setOffset(nextOffset);\n    };\n    const handleResize = () => {\n      getSize();\n      if (inkRef.value) {\n        inkRef.value.$forceUpdate();\n      }\n    };\n    watch(tabs, () => {\n      nextTick(() => {\n        getSize();\n      });\n    });\n    watch([activeIndex, scrollPosition], () => {\n      setTimeout(() => {\n        setActiveTabOffset();\n      }, 0);\n    });\n    onMounted(() => {\n      getSize();\n      if (wrapperRef.value) {\n        on(wrapperRef.value, \"wheel\", handleWheel, {\n          passive: false\n        });\n      }\n    });\n    onUnmounted(() => {\n      if (wrapperRef.value) {\n        off(wrapperRef.value, \"wheel\", handleWheel);\n      }\n    });\n    const renderAddBtn = () => {\n      if (!mergedEditable.value || !props.showAddButton) {\n        return null;\n      }\n      return createVNode(\"div\", {\n        \"class\": `${prefixCls}-add-btn`,\n        \"onClick\": ev => emit(\"add\", ev)\n      }, [createVNode(IconHover, null, {\n        default: () => [createVNode(IconPlus, null, null)]\n      })]);\n    };\n    const cls = computed(() => [prefixCls, `${prefixCls}-${props.direction}`, `${prefixCls}-${props.position}`, `${prefixCls}-size-${props.size}`, `${prefixCls}-type-${props.type}`]);\n    const listCls = computed(() => [`${prefixCls}-tab-list`, {\n      [`${prefixCls}-tab-list-no-padding`]: !props.headerPadding && [\"line\", \"text\"].includes(props.type) && props.direction === \"horizontal\"\n    }]);\n    const listStyle = computed(() => getTabListStyle({\n      direction: props.direction,\n      type: props.type,\n      offset: offset.value\n    }));\n    const tabCls = computed(() => [`${prefixCls}-tab`, {\n      [`${prefixCls}-tab-scroll`]: isScroll.value\n    }]);\n    return () => {\n      var _a;\n      return createVNode(\"div\", {\n        \"class\": cls.value\n      }, [isScroll.value && createVNode(TabsButton, {\n        \"type\": \"previous\",\n        \"direction\": props.direction,\n        \"disabled\": offset.value <= 0,\n        \"onClick\": handleButtonClick\n      }, null), createVNode(ResizeObserver, {\n        \"onResize\": () => getSize()\n      }, {\n        default: () => [createVNode(\"div\", {\n          \"class\": tabCls.value,\n          \"ref\": wrapperRef\n        }, [createVNode(ResizeObserver, {\n          \"onResize\": handleResize\n        }, {\n          default: () => [createVNode(\"div\", {\n            \"ref\": listRef,\n            \"class\": listCls.value,\n            \"style\": listStyle.value\n          }, [props.tabs.map((tab, index) => createVNode(TabsTab, {\n            \"key\": tab.key,\n            \"ref\": component => {\n              if (component == null ? void 0 : component.$el) {\n                tabsRef.value[tab.key] = component.$el;\n              }\n            },\n            \"active\": tab.key === activeKey.value,\n            \"tab\": tab,\n            \"editable\": props.editable,\n            \"onClick\": handleClick,\n            \"onDelete\": handleDelete\n          }, {\n            default: () => {\n              var _a2, _b, _c;\n              return [(_c = (_b = (_a2 = tab.slots).title) == null ? void 0 : _b.call(_a2)) != null ? _c : tab.title];\n            }\n          })), props.type === \"line\" && activeTabRef.value && createVNode(TabsNavInk, {\n            \"ref\": inkRef,\n            \"activeTabRef\": activeTabRef.value,\n            \"direction\": props.direction,\n            \"disabled\": false,\n            \"animation\": props.animation\n          }, null)])]\n        }), !isScroll.value && renderAddBtn()])]\n      }), isScroll.value && createVNode(TabsButton, {\n        \"type\": \"next\",\n        \"direction\": props.direction,\n        \"disabled\": offset.value >= maxOffset.value,\n        \"onClick\": handleButtonClick\n      }, null), createVNode(\"div\", {\n        \"class\": `${prefixCls}-extra`\n      }, [isScroll.value && renderAddBtn(), (_a = slots.extra) == null ? void 0 : _a.call(slots)])]);\n    };\n  }\n});\nexport { TabsNav as default };","map":{"version":3,"names":["defineComponent","toRefs","ref","computed","watch","nextTick","onMounted","onUnmounted","createVNode","getTabListStyle","updateScrollOffset","getPrefixCls","TabsTab","TabsButton","TabsNavInk","IconHover","IconPlus","ResizeObserver","isUndefined","isNumber","on","off","TabsNav","name","props","tabs","type","Array","required","direction","String","activeKey","Number","activeIndex","position","size","showAddButton","Boolean","default","editable","animation","headerPadding","scrollPosition","emits","setup","emit","slots","prefixCls","wrapperRef","listRef","tabsRef","activeTabRef","value","inkRef","mergedEditable","includes","isScroll","wrapperLength","maxOffset","offset","getWrapperLength","_a","_b","_c","offsetHeight","offsetWidth","getMaxOffset","getSize","isOverflow","setOffset","newOffset","Math","min","setActiveTabOffset","isHorizontal","offsetProperty","sizeProperty","tabOffset","tabSize","wrapperSize","tabStyle","window","getComputedStyle","marginProperty","tabMargin","parseFloat","handleWheel","ev","preventDefault","deltaX","deltaY","abs","handleClick","key","handleDelete","handleButtonClick","nextOffset","handleResize","$forceUpdate","setTimeout","passive","renderAddBtn","cls","listCls","listStyle","tabCls","onResize","map","tab","index","component","$el","_a2","title","call","extra"],"sources":["P:/IDEA/JudgeX/judgex_front/node_modules/@arco-design/web-vue/es/tabs/tabs-nav.js"],"sourcesContent":["import { defineComponent, toRefs, ref, computed, watch, nextTick, onMounted, onUnmounted, createVNode } from \"vue\";\nimport { getTabListStyle, updateScrollOffset } from \"./utils.js\";\nimport { getPrefixCls } from \"../_utils/global-config.js\";\nimport TabsTab from \"./tabs-tab.js\";\nimport TabsButton from \"./tabs-button.js\";\nimport TabsNavInk from \"./tabs-nav-ink.js\";\nimport IconHover from \"../_components/icon-hover.js\";\nimport IconPlus from \"../icon/icon-plus/index.js\";\nimport ResizeObserver from \"../_components/resize-observer.js\";\nimport { isUndefined, isNumber } from \"../_utils/is.js\";\nimport { on, off } from \"../_utils/dom.js\";\nvar TabsNav = defineComponent({\n  name: \"TabsNav\",\n  props: {\n    tabs: {\n      type: Array,\n      required: true\n    },\n    direction: {\n      type: String,\n      required: true\n    },\n    type: {\n      type: String,\n      required: true\n    },\n    activeKey: {\n      type: [String, Number]\n    },\n    activeIndex: {\n      type: Number,\n      required: true\n    },\n    position: {\n      type: String,\n      required: true\n    },\n    size: {\n      type: String,\n      required: true\n    },\n    showAddButton: {\n      type: Boolean,\n      default: false\n    },\n    editable: {\n      type: Boolean,\n      default: false\n    },\n    animation: {\n      type: Boolean,\n      required: true\n    },\n    headerPadding: {\n      type: Boolean,\n      default: true\n    },\n    scrollPosition: {\n      type: String,\n      default: \"auto\"\n    }\n  },\n  emits: [\"click\", \"add\", \"delete\"],\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const {\n      tabs,\n      activeKey,\n      activeIndex,\n      direction,\n      scrollPosition\n    } = toRefs(props);\n    const prefixCls = getPrefixCls(\"tabs-nav\");\n    const wrapperRef = ref();\n    const listRef = ref();\n    const tabsRef = ref({});\n    const activeTabRef = computed(() => {\n      if (!isUndefined(activeKey.value)) {\n        return tabsRef.value[activeKey.value];\n      }\n      return void 0;\n    });\n    const inkRef = ref();\n    const mergedEditable = computed(() => props.editable && [\"line\", \"card\", \"card-gutter\"].includes(props.type));\n    const isScroll = ref(false);\n    const wrapperLength = ref(0);\n    const maxOffset = ref(0);\n    const offset = ref(0);\n    const getWrapperLength = () => {\n      var _a, _b, _c;\n      return (_c = direction.value === \"vertical\" ? (_a = wrapperRef.value) == null ? void 0 : _a.offsetHeight : (_b = wrapperRef.value) == null ? void 0 : _b.offsetWidth) != null ? _c : 0;\n    };\n    const getMaxOffset = () => {\n      if (!listRef.value || !wrapperRef.value) {\n        return 0;\n      }\n      if (direction.value === \"vertical\") {\n        return listRef.value.offsetHeight - wrapperRef.value.offsetHeight;\n      }\n      return listRef.value.offsetWidth - wrapperRef.value.offsetWidth;\n    };\n    const getSize = () => {\n      isScroll.value = isOverflow();\n      if (isScroll.value) {\n        wrapperLength.value = getWrapperLength();\n        maxOffset.value = getMaxOffset();\n        if (offset.value > maxOffset.value) {\n          offset.value = maxOffset.value;\n        }\n      } else {\n        offset.value = 0;\n      }\n    };\n    const isOverflow = () => {\n      if (wrapperRef.value && listRef.value) {\n        return props.direction === \"vertical\" ? listRef.value.offsetHeight > wrapperRef.value.offsetHeight : listRef.value.offsetWidth > wrapperRef.value.offsetWidth;\n      }\n      return false;\n    };\n    const setOffset = (newOffset) => {\n      if (!wrapperRef.value || !listRef.value || newOffset < 0) {\n        newOffset = 0;\n      }\n      offset.value = Math.min(newOffset, maxOffset.value);\n    };\n    const setActiveTabOffset = () => {\n      if (!activeTabRef.value || !wrapperRef.value || !isScroll.value)\n        return;\n      updateScrollOffset(wrapperRef.value, direction.value);\n      const isHorizontal = direction.value === \"horizontal\";\n      const offsetProperty = isHorizontal ? \"offsetLeft\" : \"offsetTop\";\n      const sizeProperty = isHorizontal ? \"offsetWidth\" : \"offsetHeight\";\n      const tabOffset = activeTabRef.value[offsetProperty];\n      const tabSize = activeTabRef.value[sizeProperty];\n      const wrapperSize = wrapperRef.value[sizeProperty];\n      const tabStyle = window.getComputedStyle(activeTabRef.value);\n      const marginProperty = isHorizontal ? scrollPosition.value === \"end\" ? \"marginRight\" : \"marginLeft\" : scrollPosition.value === \"end\" ? \"marginBottom\" : \"marginTop\";\n      const tabMargin = parseFloat(tabStyle[marginProperty]) || 0;\n      if (scrollPosition.value === \"auto\") {\n        if (tabOffset < offset.value) {\n          setOffset(tabOffset - tabMargin);\n        } else if (tabOffset + tabSize > offset.value + wrapperSize) {\n          setOffset(tabOffset + tabSize - wrapperSize + tabMargin);\n        }\n      } else if (scrollPosition.value === \"center\") {\n        setOffset(tabOffset + (tabSize - wrapperSize + tabMargin) / 2);\n      } else if (scrollPosition.value === \"start\") {\n        setOffset(tabOffset - tabMargin);\n      } else if (scrollPosition.value === \"end\") {\n        setOffset(tabOffset + tabSize - wrapperSize + tabMargin);\n      } else if (isNumber(scrollPosition.value)) {\n        setOffset(tabOffset - scrollPosition.value);\n      }\n    };\n    const handleWheel = (ev) => {\n      if (!isScroll.value)\n        return;\n      ev.preventDefault();\n      const {\n        deltaX,\n        deltaY\n      } = ev;\n      if (Math.abs(deltaX) > Math.abs(deltaY)) {\n        setOffset(offset.value + deltaX);\n      } else {\n        setOffset(offset.value + deltaY);\n      }\n    };\n    const handleClick = (key, ev) => {\n      emit(\"click\", key, ev);\n    };\n    const handleDelete = (key, ev) => {\n      emit(\"delete\", key, ev);\n      nextTick(() => {\n        delete tabsRef.value[key];\n      });\n    };\n    const handleButtonClick = (type) => {\n      const nextOffset = type === \"previous\" ? offset.value - wrapperLength.value : offset.value + wrapperLength.value;\n      setOffset(nextOffset);\n    };\n    const handleResize = () => {\n      getSize();\n      if (inkRef.value) {\n        inkRef.value.$forceUpdate();\n      }\n    };\n    watch(tabs, () => {\n      nextTick(() => {\n        getSize();\n      });\n    });\n    watch([activeIndex, scrollPosition], () => {\n      setTimeout(() => {\n        setActiveTabOffset();\n      }, 0);\n    });\n    onMounted(() => {\n      getSize();\n      if (wrapperRef.value) {\n        on(wrapperRef.value, \"wheel\", handleWheel, {\n          passive: false\n        });\n      }\n    });\n    onUnmounted(() => {\n      if (wrapperRef.value) {\n        off(wrapperRef.value, \"wheel\", handleWheel);\n      }\n    });\n    const renderAddBtn = () => {\n      if (!mergedEditable.value || !props.showAddButton) {\n        return null;\n      }\n      return createVNode(\"div\", {\n        \"class\": `${prefixCls}-add-btn`,\n        \"onClick\": (ev) => emit(\"add\", ev)\n      }, [createVNode(IconHover, null, {\n        default: () => [createVNode(IconPlus, null, null)]\n      })]);\n    };\n    const cls = computed(() => [prefixCls, `${prefixCls}-${props.direction}`, `${prefixCls}-${props.position}`, `${prefixCls}-size-${props.size}`, `${prefixCls}-type-${props.type}`]);\n    const listCls = computed(() => [`${prefixCls}-tab-list`, {\n      [`${prefixCls}-tab-list-no-padding`]: !props.headerPadding && [\"line\", \"text\"].includes(props.type) && props.direction === \"horizontal\"\n    }]);\n    const listStyle = computed(() => getTabListStyle({\n      direction: props.direction,\n      type: props.type,\n      offset: offset.value\n    }));\n    const tabCls = computed(() => [`${prefixCls}-tab`, {\n      [`${prefixCls}-tab-scroll`]: isScroll.value\n    }]);\n    return () => {\n      var _a;\n      return createVNode(\"div\", {\n        \"class\": cls.value\n      }, [isScroll.value && createVNode(TabsButton, {\n        \"type\": \"previous\",\n        \"direction\": props.direction,\n        \"disabled\": offset.value <= 0,\n        \"onClick\": handleButtonClick\n      }, null), createVNode(ResizeObserver, {\n        \"onResize\": () => getSize()\n      }, {\n        default: () => [createVNode(\"div\", {\n          \"class\": tabCls.value,\n          \"ref\": wrapperRef\n        }, [createVNode(ResizeObserver, {\n          \"onResize\": handleResize\n        }, {\n          default: () => [createVNode(\"div\", {\n            \"ref\": listRef,\n            \"class\": listCls.value,\n            \"style\": listStyle.value\n          }, [props.tabs.map((tab, index) => createVNode(TabsTab, {\n            \"key\": tab.key,\n            \"ref\": (component) => {\n              if (component == null ? void 0 : component.$el) {\n                tabsRef.value[tab.key] = component.$el;\n              }\n            },\n            \"active\": tab.key === activeKey.value,\n            \"tab\": tab,\n            \"editable\": props.editable,\n            \"onClick\": handleClick,\n            \"onDelete\": handleDelete\n          }, {\n            default: () => {\n              var _a2, _b, _c;\n              return [(_c = (_b = (_a2 = tab.slots).title) == null ? void 0 : _b.call(_a2)) != null ? _c : tab.title];\n            }\n          })), props.type === \"line\" && activeTabRef.value && createVNode(TabsNavInk, {\n            \"ref\": inkRef,\n            \"activeTabRef\": activeTabRef.value,\n            \"direction\": props.direction,\n            \"disabled\": false,\n            \"animation\": props.animation\n          }, null)])]\n        }), !isScroll.value && renderAddBtn()])]\n      }), isScroll.value && createVNode(TabsButton, {\n        \"type\": \"next\",\n        \"direction\": props.direction,\n        \"disabled\": offset.value >= maxOffset.value,\n        \"onClick\": handleButtonClick\n      }, null), createVNode(\"div\", {\n        \"class\": `${prefixCls}-extra`\n      }, [isScroll.value && renderAddBtn(), (_a = slots.extra) == null ? void 0 : _a.call(slots)])]);\n    };\n  }\n});\nexport { TabsNav as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}