{"ast":null,"code":"var _TextModel;\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n  const builder = new PieceTreeTextBufferBuilder();\n  builder.acceptChunk(text);\n  return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n  const builder = new PieceTreeTextBufferBuilder();\n  let chunk;\n  while (typeof (chunk = snapshot.read()) === 'string') {\n    builder.acceptChunk(chunk);\n  }\n  return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n  let factory;\n  if (typeof value === 'string') {\n    factory = createTextBufferFactory(value);\n  } else if (model.isITextSnapshot(value)) {\n    factory = createTextBufferFactoryFromSnapshot(value);\n  } else {\n    factory = value;\n  }\n  return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n  constructor(source) {\n    this._source = source;\n    this._eos = false;\n  }\n  read() {\n    if (this._eos) {\n      return null;\n    }\n    const result = [];\n    let resultCnt = 0;\n    let resultLength = 0;\n    do {\n      const tmp = this._source.read();\n      if (tmp === null) {\n        // end-of-stream\n        this._eos = true;\n        if (resultCnt === 0) {\n          return null;\n        } else {\n          return result.join('');\n        }\n      }\n      if (tmp.length > 0) {\n        result[resultCnt++] = tmp;\n        resultLength += tmp.length;\n      }\n      if (resultLength >= 64 * 1024) {\n        return result.join('');\n      }\n    } while (true);\n  }\n}\nconst invalidFunc = () => {\n  throw new Error(`Invalid change accessor`);\n};\nlet TextModel = (_TextModel = class TextModel extends Disposable {\n  static resolveOptions(textBuffer, options) {\n    if (options.detectIndentation) {\n      const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n      return new model.TextModelResolvedOptions({\n        tabSize: guessedIndentation.tabSize,\n        indentSize: 'tabSize',\n        // TODO@Alex: guess indentSize independent of tabSize\n        insertSpaces: guessedIndentation.insertSpaces,\n        trimAutoWhitespace: options.trimAutoWhitespace,\n        defaultEOL: options.defaultEOL,\n        bracketPairColorizationOptions: options.bracketPairColorizationOptions\n      });\n    }\n    return new model.TextModelResolvedOptions(options);\n  }\n  get onDidChangeLanguage() {\n    return this._tokenizationTextModelPart.onDidChangeLanguage;\n  }\n  get onDidChangeLanguageConfiguration() {\n    return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;\n  }\n  get onDidChangeTokens() {\n    return this._tokenizationTextModelPart.onDidChangeTokens;\n  }\n  onDidChangeContent(listener) {\n    return this._eventEmitter.slowEvent(e => listener(e.contentChangedEvent));\n  }\n  onDidChangeContentOrInjectedText(listener) {\n    return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n  }\n  _isDisposing() {\n    return this.__isDisposing;\n  }\n  get tokenization() {\n    return this._tokenizationTextModelPart;\n  }\n  get bracketPairs() {\n    return this._bracketPairs;\n  }\n  get guides() {\n    return this._guidesTextModelPart;\n  }\n  constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n    super();\n    this._undoRedoService = _undoRedoService;\n    this._languageService = _languageService;\n    this._languageConfigurationService = _languageConfigurationService;\n    this.instantiationService = instantiationService;\n    //#region Events\n    this._onWillDispose = this._register(new Emitter());\n    this.onWillDispose = this._onWillDispose.event;\n    this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n    this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n    this._onDidChangeOptions = this._register(new Emitter());\n    this.onDidChangeOptions = this._onDidChangeOptions.event;\n    this._onDidChangeAttached = this._register(new Emitter());\n    this.onDidChangeAttached = this._onDidChangeAttached.event;\n    this._onDidChangeInjectedText = this._register(new Emitter());\n    this._eventEmitter = this._register(new DidChangeContentEmitter());\n    this._languageSelectionListener = this._register(new MutableDisposable());\n    this._deltaDecorationCallCnt = 0;\n    this._attachedViews = new AttachedViews();\n    // Generate a new unique model id\n    MODEL_ID++;\n    this.id = '$model' + MODEL_ID;\n    this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n    if (typeof associatedResource === 'undefined' || associatedResource === null) {\n      this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n    } else {\n      this._associatedResource = associatedResource;\n    }\n    this._attachedEditorCount = 0;\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(source, creationOptions.defaultEOL);\n    this._buffer = textBuffer;\n    this._bufferDisposable = disposable;\n    this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n    const languageId = typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId;\n    if (typeof languageIdOrSelection !== 'string') {\n      this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n    }\n    this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n    this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n    this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n    this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n    const bufferLineCount = this._buffer.getLineCount();\n    const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n    // !!! Make a decision in the ctor and permanently respect this decision !!!\n    // If a model is too large at construction time, it will never get tokenized,\n    // under no circumstances.\n    if (creationOptions.largeFileOptimizations) {\n      this._isTooLargeForTokenization = bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD;\n      this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n    } else {\n      this._isTooLargeForTokenization = false;\n      this._isTooLargeForHeapOperation = false;\n    }\n    this._isTooLargeForSyncing = bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT;\n    this._versionId = 1;\n    this._alternativeVersionId = 1;\n    this._initialUndoRedoSnapshot = null;\n    this._isDisposed = false;\n    this.__isDisposing = false;\n    this._instanceId = strings.singleLetterHash(MODEL_ID);\n    this._lastDecorationId = 0;\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    this._commandManager = new EditStack(this, this._undoRedoService);\n    this._isUndoing = false;\n    this._isRedoing = false;\n    this._trimAutoWhitespaceLines = null;\n    this._register(this._decorationProvider.onDidChange(() => {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._onDidChangeDecorations.fire();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }));\n    this._languageService.requestRichLanguageFeatures(languageId);\n    this._register(this._languageConfigurationService.onDidChange(e => {\n      this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n      this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n    }));\n  }\n  dispose() {\n    this.__isDisposing = true;\n    this._onWillDispose.fire();\n    this._tokenizationTextModelPart.dispose();\n    this._isDisposed = true;\n    super.dispose();\n    this._bufferDisposable.dispose();\n    this.__isDisposing = false;\n    // Manually release reference to previous text buffer to avoid large leaks\n    // in case someone leaks a TextModel reference\n    const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n    emptyDisposedTextBuffer.dispose();\n    this._buffer = emptyDisposedTextBuffer;\n    this._bufferDisposable = Disposable.None;\n  }\n  _assertNotDisposed() {\n    if (this._isDisposed) {\n      throw new BugIndicatingError('Model is disposed!');\n    }\n  }\n  _emitContentChangedEvent(rawChange, change) {\n    if (this.__isDisposing) {\n      // Do not confuse listeners by emitting any event after disposing\n      return;\n    }\n    this._tokenizationTextModelPart.handleDidChangeContent(change);\n    this._bracketPairs.handleDidChangeContent(change);\n    this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n  }\n  setValue(value) {\n    this._assertNotDisposed();\n    if (value === null || value === undefined) {\n      throw illegalArgument();\n    }\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(value, this._options.defaultEOL);\n    this._setValueFromTextBuffer(textBuffer, disposable);\n  }\n  _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n    return {\n      changes: [{\n        range: range,\n        rangeOffset: rangeOffset,\n        rangeLength: rangeLength,\n        text: text\n      }],\n      eol: this._buffer.getEOL(),\n      isEolChange: isEolChange,\n      versionId: this.getVersionId(),\n      isUndoing: isUndoing,\n      isRedoing: isRedoing,\n      isFlush: isFlush\n    };\n  }\n  _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n    this._assertNotDisposed();\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._buffer = textBuffer;\n    this._bufferDisposable.dispose();\n    this._bufferDisposable = textBufferDisposable;\n    this._increaseVersionId();\n    // Destroy all my decorations\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    // Destroy my edit history and settings\n    this._commandManager.clear();\n    this._trimAutoWhitespaceLines = null;\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawFlush()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n  }\n  setEOL(eol) {\n    this._assertNotDisposed();\n    const newEOL = eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n';\n    if (this._buffer.getEOL() === newEOL) {\n      // Nothing to do\n      return;\n    }\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._onBeforeEOLChange();\n    this._buffer.setEOL(newEOL);\n    this._increaseVersionId();\n    this._onAfterEOLChange();\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawEOLChanged()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n  }\n  _onBeforeEOLChange() {\n    // Ensure all decorations get their `range` set.\n    this._decorationsTree.ensureAllNodesHaveRanges(this);\n  }\n  _onAfterEOLChange() {\n    // Transform back `range` to offsets\n    const versionId = this.getVersionId();\n    const allDecorations = this._decorationsTree.collectNodesPostOrder();\n    for (let i = 0, len = allDecorations.length; i < len; i++) {\n      const node = allDecorations[i];\n      const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n      const delta = node.cachedAbsoluteStart - node.start;\n      const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n      const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n      node.cachedAbsoluteStart = startOffset;\n      node.cachedAbsoluteEnd = endOffset;\n      node.cachedVersionId = versionId;\n      node.start = startOffset - delta;\n      node.end = endOffset - delta;\n      recomputeMaxEnd(node);\n    }\n  }\n  onBeforeAttached() {\n    this._attachedEditorCount++;\n    if (this._attachedEditorCount === 1) {\n      this._tokenizationTextModelPart.handleDidChangeAttached();\n      this._onDidChangeAttached.fire(undefined);\n    }\n    return this._attachedViews.attachView();\n  }\n  onBeforeDetached(view) {\n    this._attachedEditorCount--;\n    if (this._attachedEditorCount === 0) {\n      this._tokenizationTextModelPart.handleDidChangeAttached();\n      this._onDidChangeAttached.fire(undefined);\n    }\n    this._attachedViews.detachView(view);\n  }\n  isAttachedToEditor() {\n    return this._attachedEditorCount > 0;\n  }\n  getAttachedEditorCount() {\n    return this._attachedEditorCount;\n  }\n  isTooLargeForSyncing() {\n    return this._isTooLargeForSyncing;\n  }\n  isTooLargeForTokenization() {\n    return this._isTooLargeForTokenization;\n  }\n  isTooLargeForHeapOperation() {\n    return this._isTooLargeForHeapOperation;\n  }\n  isDisposed() {\n    return this._isDisposed;\n  }\n  isDominatedByLongLines() {\n    this._assertNotDisposed();\n    if (this.isTooLargeForTokenization()) {\n      // Cannot word wrap huge files anyways, so it doesn't really matter\n      return false;\n    }\n    let smallLineCharCount = 0;\n    let longLineCharCount = 0;\n    const lineCount = this._buffer.getLineCount();\n    for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n      const lineLength = this._buffer.getLineLength(lineNumber);\n      if (lineLength >= LONG_LINE_BOUNDARY) {\n        longLineCharCount += lineLength;\n      } else {\n        smallLineCharCount += lineLength;\n      }\n    }\n    return longLineCharCount > smallLineCharCount;\n  }\n  get uri() {\n    return this._associatedResource;\n  }\n  //#region Options\n  getOptions() {\n    this._assertNotDisposed();\n    return this._options;\n  }\n  getFormattingOptions() {\n    return {\n      tabSize: this._options.indentSize,\n      insertSpaces: this._options.insertSpaces\n    };\n  }\n  updateOptions(_newOpts) {\n    this._assertNotDisposed();\n    const tabSize = typeof _newOpts.tabSize !== 'undefined' ? _newOpts.tabSize : this._options.tabSize;\n    const indentSize = typeof _newOpts.indentSize !== 'undefined' ? _newOpts.indentSize : this._options.originalIndentSize;\n    const insertSpaces = typeof _newOpts.insertSpaces !== 'undefined' ? _newOpts.insertSpaces : this._options.insertSpaces;\n    const trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== 'undefined' ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n    const bracketPairColorizationOptions = typeof _newOpts.bracketColorizationOptions !== 'undefined' ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n    const newOpts = new model.TextModelResolvedOptions({\n      tabSize: tabSize,\n      indentSize: indentSize,\n      insertSpaces: insertSpaces,\n      defaultEOL: this._options.defaultEOL,\n      trimAutoWhitespace: trimAutoWhitespace,\n      bracketPairColorizationOptions\n    });\n    if (this._options.equals(newOpts)) {\n      return;\n    }\n    const e = this._options.createChangeEvent(newOpts);\n    this._options = newOpts;\n    this._bracketPairs.handleDidChangeOptions(e);\n    this._decorationProvider.handleDidChangeOptions(e);\n    this._onDidChangeOptions.fire(e);\n  }\n  detectIndentation(defaultInsertSpaces, defaultTabSize) {\n    this._assertNotDisposed();\n    const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n    this.updateOptions({\n      insertSpaces: guessedIndentation.insertSpaces,\n      tabSize: guessedIndentation.tabSize,\n      indentSize: guessedIndentation.tabSize // TODO@Alex: guess indentSize independent of tabSize\n    });\n  }\n  normalizeIndentation(str) {\n    this._assertNotDisposed();\n    return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n  }\n  //#endregion\n  //#region Reading\n  getVersionId() {\n    this._assertNotDisposed();\n    return this._versionId;\n  }\n  mightContainRTL() {\n    return this._buffer.mightContainRTL();\n  }\n  mightContainUnusualLineTerminators() {\n    return this._buffer.mightContainUnusualLineTerminators();\n  }\n  removeUnusualLineTerminators(selections = null) {\n    const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n    this._buffer.resetMightContainUnusualLineTerminators();\n    this.pushEditOperations(selections, matches.map(m => ({\n      range: m.range,\n      text: null\n    })), () => null);\n  }\n  mightContainNonBasicASCII() {\n    return this._buffer.mightContainNonBasicASCII();\n  }\n  getAlternativeVersionId() {\n    this._assertNotDisposed();\n    return this._alternativeVersionId;\n  }\n  getInitialUndoRedoSnapshot() {\n    this._assertNotDisposed();\n    return this._initialUndoRedoSnapshot;\n  }\n  getOffsetAt(rawPosition) {\n    this._assertNotDisposed();\n    const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n    return this._buffer.getOffsetAt(position.lineNumber, position.column);\n  }\n  getPositionAt(rawOffset) {\n    this._assertNotDisposed();\n    const offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));\n    return this._buffer.getPositionAt(offset);\n  }\n  _increaseVersionId() {\n    this._versionId = this._versionId + 1;\n    this._alternativeVersionId = this._versionId;\n  }\n  _overwriteVersionId(versionId) {\n    this._versionId = versionId;\n  }\n  _overwriteAlternativeVersionId(newAlternativeVersionId) {\n    this._alternativeVersionId = newAlternativeVersionId;\n  }\n  _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n    this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n  }\n  getValue(eol, preserveBOM = false) {\n    this._assertNotDisposed();\n    if (this.isTooLargeForHeapOperation()) {\n      throw new BugIndicatingError('Operation would exceed heap memory limits');\n    }\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueInRange(fullModelRange, eol);\n    if (preserveBOM) {\n      return this._buffer.getBOM() + fullModelValue;\n    }\n    return fullModelValue;\n  }\n  createSnapshot(preserveBOM = false) {\n    return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n  }\n  getValueLength(eol, preserveBOM = false) {\n    this._assertNotDisposed();\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n    if (preserveBOM) {\n      return this._buffer.getBOM().length + fullModelValue;\n    }\n    return fullModelValue;\n  }\n  getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n    this._assertNotDisposed();\n    return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n  }\n  getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n    this._assertNotDisposed();\n    return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n  }\n  getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n    this._assertNotDisposed();\n    return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n  }\n  getLineCount() {\n    this._assertNotDisposed();\n    return this._buffer.getLineCount();\n  }\n  getLineContent(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineContent(lineNumber);\n  }\n  getLineLength(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLength(lineNumber);\n  }\n  getLinesContent() {\n    this._assertNotDisposed();\n    if (this.isTooLargeForHeapOperation()) {\n      throw new BugIndicatingError('Operation would exceed heap memory limits');\n    }\n    return this._buffer.getLinesContent();\n  }\n  getEOL() {\n    this._assertNotDisposed();\n    return this._buffer.getEOL();\n  }\n  getEndOfLineSequence() {\n    this._assertNotDisposed();\n    return this._buffer.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */;\n  }\n  getLineMinColumn(lineNumber) {\n    this._assertNotDisposed();\n    return 1;\n  }\n  getLineMaxColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLength(lineNumber) + 1;\n  }\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n  }\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n  }\n  /**\n   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n   * Will try to not allocate if possible.\n   */\n  _validateRangeRelaxedNoAllocations(range) {\n    const linesCount = this._buffer.getLineCount();\n    const initialStartLineNumber = range.startLineNumber;\n    const initialStartColumn = range.startColumn;\n    let startLineNumber = Math.floor(typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber) ? initialStartLineNumber : 1);\n    let startColumn = Math.floor(typeof initialStartColumn === 'number' && !isNaN(initialStartColumn) ? initialStartColumn : 1);\n    if (startLineNumber < 1) {\n      startLineNumber = 1;\n      startColumn = 1;\n    } else if (startLineNumber > linesCount) {\n      startLineNumber = linesCount;\n      startColumn = this.getLineMaxColumn(startLineNumber);\n    } else {\n      if (startColumn <= 1) {\n        startColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(startLineNumber);\n        if (startColumn >= maxColumn) {\n          startColumn = maxColumn;\n        }\n      }\n    }\n    const initialEndLineNumber = range.endLineNumber;\n    const initialEndColumn = range.endColumn;\n    let endLineNumber = Math.floor(typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber) ? initialEndLineNumber : 1);\n    let endColumn = Math.floor(typeof initialEndColumn === 'number' && !isNaN(initialEndColumn) ? initialEndColumn : 1);\n    if (endLineNumber < 1) {\n      endLineNumber = 1;\n      endColumn = 1;\n    } else if (endLineNumber > linesCount) {\n      endLineNumber = linesCount;\n      endColumn = this.getLineMaxColumn(endLineNumber);\n    } else {\n      if (endColumn <= 1) {\n        endColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(endLineNumber);\n        if (endColumn >= maxColumn) {\n          endColumn = maxColumn;\n        }\n      }\n    }\n    if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range instanceof Range && !(range instanceof Selection)) {\n      return range;\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  _isValidPosition(lineNumber, column, validationType) {\n    if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n      return false;\n    }\n    if (isNaN(lineNumber) || isNaN(column)) {\n      return false;\n    }\n    if (lineNumber < 1 || column < 1) {\n      return false;\n    }\n    if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n      return false;\n    }\n    const lineCount = this._buffer.getLineCount();\n    if (lineNumber > lineCount) {\n      return false;\n    }\n    if (column === 1) {\n      return true;\n    }\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n    if (column > maxColumn) {\n      return false;\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _validatePosition(_lineNumber, _column, validationType) {\n    const lineNumber = Math.floor(typeof _lineNumber === 'number' && !isNaN(_lineNumber) ? _lineNumber : 1);\n    const column = Math.floor(typeof _column === 'number' && !isNaN(_column) ? _column : 1);\n    const lineCount = this._buffer.getLineCount();\n    if (lineNumber < 1) {\n      return new Position(1, 1);\n    }\n    if (lineNumber > lineCount) {\n      return new Position(lineCount, this.getLineMaxColumn(lineCount));\n    }\n    if (column <= 1) {\n      return new Position(lineNumber, 1);\n    }\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n    if (column >= maxColumn) {\n      return new Position(lineNumber, maxColumn);\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      // If the position would end up in the middle of a high-low surrogate pair,\n      // we move it to before the pair\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return new Position(lineNumber, column - 1);\n      }\n    }\n    return new Position(lineNumber, column);\n  }\n  validatePosition(position) {\n    const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n    this._assertNotDisposed();\n    // Avoid object allocation and cover most likely case\n    if (position instanceof Position) {\n      if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n        return position;\n      }\n    }\n    return this._validatePosition(position.lineNumber, position.column, validationType);\n  }\n  _isValidRange(range, validationType) {\n    const startLineNumber = range.startLineNumber;\n    const startColumn = range.startColumn;\n    const endLineNumber = range.endLineNumber;\n    const endColumn = range.endColumn;\n    if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n      return false;\n    }\n    if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n      return false;\n    }\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return true;\n      }\n      return false;\n    }\n    return true;\n  }\n  validateRange(_range) {\n    const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n    this._assertNotDisposed();\n    // Avoid object allocation and cover most likely case\n    if (_range instanceof Range && !(_range instanceof Selection)) {\n      if (this._isValidRange(_range, validationType)) {\n        return _range;\n      }\n    }\n    const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n    const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n    const startLineNumber = start.lineNumber;\n    const startColumn = start.column;\n    const endLineNumber = end.lineNumber;\n    const endColumn = end.column;\n    if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      }\n      if (startLineNumber === endLineNumber && startColumn === endColumn) {\n        // do not expand a collapsed range, simply move it to a valid location\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n      }\n      if (startInsideSurrogatePair && endInsideSurrogatePair) {\n        // expand range at both ends\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n      }\n      if (startInsideSurrogatePair) {\n        // only expand range at the start\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n      }\n      // only expand range at the end\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  modifyPosition(rawPosition, offset) {\n    this._assertNotDisposed();\n    const candidate = this.getOffsetAt(rawPosition) + offset;\n    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n  }\n  getFullModelRange() {\n    this._assertNotDisposed();\n    const lineCount = this.getLineCount();\n    return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n  }\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  }\n  findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n    this._assertNotDisposed();\n    let searchRanges = null;\n    if (rawSearchScope !== null) {\n      if (!Array.isArray(rawSearchScope)) {\n        rawSearchScope = [rawSearchScope];\n      }\n      if (rawSearchScope.every(searchScope => Range.isIRange(searchScope))) {\n        searchRanges = rawSearchScope.map(searchScope => this.validateRange(searchScope));\n      }\n    }\n    if (searchRanges === null) {\n      searchRanges = [this.getFullModelRange()];\n    }\n    searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n    const uniqueSearchRanges = [];\n    uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n      if (Range.areIntersecting(prev, curr)) {\n        return prev.plusRange(curr);\n      }\n      uniqueSearchRanges.push(prev);\n      return curr;\n    }));\n    let matchMapper;\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      // not regex, not multi line\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return [];\n      }\n      matchMapper = searchRange => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    } else {\n      matchMapper = searchRange => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n    }\n    return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n  }\n  findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n    const searchStart = this.validatePosition(rawSearchStart);\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return null;\n      }\n      const lineCount = this.getLineCount();\n      let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n      let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n      if (ret.length > 0) {\n        return ret[0];\n      }\n      searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n      ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      if (ret.length > 0) {\n        return ret[0];\n      }\n      return null;\n    }\n    return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n  findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n    const searchStart = this.validatePosition(rawSearchStart);\n    return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n  //#endregion\n  //#region Editing\n  pushStackElement() {\n    this._commandManager.pushStackElement();\n  }\n  popStackElement() {\n    this._commandManager.popStackElement();\n  }\n  pushEOL(eol) {\n    const currentEOL = this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */;\n    if (currentEOL === eol) {\n      return;\n    }\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      if (this._initialUndoRedoSnapshot === null) {\n        this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n      }\n      this._commandManager.pushEOL(eol);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _validateEditOperation(rawOperation) {\n    if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n      return rawOperation;\n    }\n    return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n  }\n  _validateEditOperations(rawOperations) {\n    const result = [];\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      result[i] = this._validateEditOperation(rawOperations[i]);\n    }\n    return result;\n  }\n  pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n      // Go through each saved line number and insert a trim whitespace edit\n      // if it is safe to do so (no conflicts with other edits).\n      const incomingEdits = editOperations.map(op => {\n        return {\n          range: this.validateRange(op.range),\n          text: op.text\n        };\n      });\n      // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n      // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n      let editsAreNearCursors = true;\n      if (beforeCursorState) {\n        for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n          const sel = beforeCursorState[i];\n          let foundEditNearSel = false;\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            const editRange = incomingEdits[j].range;\n            const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n            const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n            if (!selIsAbove && !selIsBelow) {\n              foundEditNearSel = true;\n              break;\n            }\n          }\n          if (!foundEditNearSel) {\n            editsAreNearCursors = false;\n            break;\n          }\n        }\n      }\n      if (editsAreNearCursors) {\n        for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n          const trimLineNumber = this._trimAutoWhitespaceLines[i];\n          const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n          let allowTrimLine = true;\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            const editRange = incomingEdits[j].range;\n            const editText = incomingEdits[j].text;\n            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n              // `trimLine` is completely outside this edit\n              continue;\n            }\n            // At this point:\n            //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n              // This edit inserts a new line (and maybe other text) after `trimLine`\n              continue;\n            }\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n              // This edit inserts a new line (and maybe other text) before `trimLine`\n              continue;\n            }\n            // Looks like we can't trim this line as it would interfere with an incoming edit\n            allowTrimLine = false;\n            break;\n          }\n          if (allowTrimLine) {\n            const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n            editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n          }\n        }\n      }\n      this._trimAutoWhitespaceLines = null;\n    }\n    if (this._initialUndoRedoSnapshot === null) {\n      this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n    }\n    return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n  }\n  _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.newPosition);\n      const rangeEnd = this.getPositionAt(change.newEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.oldText\n      };\n    });\n    this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n  }\n  _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.oldPosition);\n      const rangeEnd = this.getPositionAt(change.oldEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.newText\n      };\n    });\n    this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n  }\n  _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      this._isUndoing = isUndoing;\n      this._isRedoing = isRedoing;\n      this.applyEdits(edits, false);\n      this.setEOL(eol);\n      this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n    } finally {\n      this._isUndoing = false;\n      this._isRedoing = false;\n      this._eventEmitter.endDeferredEmit(resultingSelection);\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  applyEdits(rawOperations, computeUndoEdits = false) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      const operations = this._validateEditOperations(rawOperations);\n      return this._doApplyEdits(operations, computeUndoEdits);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _doApplyEdits(rawOperations, computeUndoEdits) {\n    const oldLineCount = this._buffer.getLineCount();\n    const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n    const newLineCount = this._buffer.getLineCount();\n    const contentChanges = result.changes;\n    this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n    if (contentChanges.length !== 0) {\n      // We do a first pass to update decorations\n      // because we want to read decorations in the second pass\n      // where we will emit content change events\n      // and we want to read the final decorations\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n      }\n      const rawContentChanges = [];\n      this._increaseVersionId();\n      let lineCount = oldLineCount;\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        const [eolCount] = countEOL(change.text);\n        this._onDidChangeDecorations.fire();\n        const startLineNumber = change.range.startLineNumber;\n        const endLineNumber = change.range.endLineNumber;\n        const deletingLinesCnt = endLineNumber - startLineNumber;\n        const insertingLinesCnt = eolCount;\n        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n        const changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;\n        const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n        const firstEditLineNumber = currentEditStartLineNumber;\n        const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n        const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n        const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n        const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n        for (let j = editingLinesCnt; j >= 0; j--) {\n          const editLineNumber = startLineNumber + j;\n          const currentEditLineNumber = currentEditStartLineNumber + j;\n          injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n          const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n          rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n        }\n        if (editingLinesCnt < deletingLinesCnt) {\n          // Must delete some lines\n          const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n          rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n        }\n        if (editingLinesCnt < insertingLinesCnt) {\n          const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n          // Must insert some lines\n          const spliceLineNumber = startLineNumber + editingLinesCnt;\n          const cnt = insertingLinesCnt - editingLinesCnt;\n          const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n          const injectedTexts = [];\n          const newLines = [];\n          for (let i = 0; i < cnt; i++) {\n            const lineNumber = fromLineNumber + i;\n            newLines[i] = this.getLineContent(lineNumber);\n            injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n            injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n          }\n          rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n        }\n        lineCount += changeLineCountDelta;\n      }\n      this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n        changes: contentChanges,\n        eol: this._buffer.getEOL(),\n        isEolChange: false,\n        versionId: this.getVersionId(),\n        isUndoing: this._isUndoing,\n        isRedoing: this._isRedoing,\n        isFlush: false\n      });\n    }\n    return result.reverseEdits === null ? undefined : result.reverseEdits;\n  }\n  undo() {\n    return this._undoRedoService.undo(this.uri);\n  }\n  canUndo() {\n    return this._undoRedoService.canUndo(this.uri);\n  }\n  redo() {\n    return this._undoRedoService.redo(this.uri);\n  }\n  canRedo() {\n    return this._undoRedoService.canRedo(this.uri);\n  }\n  //#endregion\n  //#region Decorations\n  handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n    // This is called before the decoration changed event is fired.\n    if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n      return;\n    }\n    const affectedLines = Array.from(affectedInjectedTextLines);\n    const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n    this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n  }\n  changeDecorations(callback, ownerId = 0) {\n    this._assertNotDisposed();\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      return this._changeDecorations(ownerId, callback);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _changeDecorations(ownerId, callback) {\n    const changeAccessor = {\n      addDecoration: (range, options) => {\n        return this._deltaDecorationsImpl(ownerId, [], [{\n          range: range,\n          options: options\n        }])[0];\n      },\n      changeDecoration: (id, newRange) => {\n        this._changeDecorationImpl(id, newRange);\n      },\n      changeDecorationOptions: (id, options) => {\n        this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n      },\n      removeDecoration: id => {\n        this._deltaDecorationsImpl(ownerId, [id], []);\n      },\n      deltaDecorations: (oldDecorations, newDecorations) => {\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n          // nothing to do\n          return [];\n        }\n        return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n      }\n    };\n    let result = null;\n    try {\n      result = callback(changeAccessor);\n    } catch (e) {\n      onUnexpectedError(e);\n    }\n    // Invalidate change accessor\n    changeAccessor.addDecoration = invalidFunc;\n    changeAccessor.changeDecoration = invalidFunc;\n    changeAccessor.changeDecorationOptions = invalidFunc;\n    changeAccessor.removeDecoration = invalidFunc;\n    changeAccessor.deltaDecorations = invalidFunc;\n    return result;\n  }\n  deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n    this._assertNotDisposed();\n    if (!oldDecorations) {\n      oldDecorations = [];\n    }\n    if (oldDecorations.length === 0 && newDecorations.length === 0) {\n      // nothing to do\n      return [];\n    }\n    try {\n      this._deltaDecorationCallCnt++;\n      if (this._deltaDecorationCallCnt > 1) {\n        console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n        onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n      }\n      this._onDidChangeDecorations.beginDeferredEmit();\n      return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n      this._deltaDecorationCallCnt--;\n    }\n  }\n  _getTrackedRange(id) {\n    return this.getDecorationRange(id);\n  }\n  _setTrackedRange(id, newRange, newStickiness) {\n    const node = id ? this._decorations[id] : null;\n    if (!node) {\n      if (!newRange) {\n        // node doesn't exist, the request is to delete => nothing to do\n        return null;\n      }\n      // node doesn't exist, the request is to set => add the tracked range\n      return this._deltaDecorationsImpl(0, [], [{\n        range: newRange,\n        options: TRACKED_RANGE_OPTIONS[newStickiness]\n      }], true)[0];\n    }\n    if (!newRange) {\n      // node exists, the request is to delete => delete node\n      this._decorationsTree.delete(node);\n      delete this._decorations[node.id];\n      return null;\n    }\n    // node exists, the request is to set => change the tracked range and its options\n    const range = this._validateRangeRelaxedNoAllocations(newRange);\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n    this._decorationsTree.delete(node);\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n    this._decorationsTree.insert(node);\n    return node.id;\n  }\n  removeAllDecorationsWithOwnerId(ownerId) {\n    if (this._isDisposed) {\n      return;\n    }\n    const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n    for (let i = 0, len = nodes.length; i < len; i++) {\n      const node = nodes[i];\n      this._decorationsTree.delete(node);\n      delete this._decorations[node.id];\n    }\n  }\n  getDecorationOptions(decorationId) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return null;\n    }\n    return node.options;\n  }\n  getDecorationRange(decorationId) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return null;\n    }\n    return this._decorationsTree.getNodeRange(this, node);\n  }\n  getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      return [];\n    }\n    return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n  }\n  getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n    const lineCount = this.getLineCount();\n    const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n    const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n    const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n    pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n    return decorations;\n  }\n  getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n    const validatedRange = this.validateRange(range);\n    const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n    pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n    return decorations;\n  }\n  getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n    return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n  }\n  getInjectedTextDecorations(ownerId = 0) {\n    return this._decorationsTree.getAllInjectedText(this, ownerId);\n  }\n  _getInjectedTextInLine(lineNumber) {\n    const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n    const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n    const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n    return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n  }\n  getAllDecorations(ownerId = 0, filterOutValidation = false) {\n    let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n    result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n    return result;\n  }\n  getAllMarginDecorations(ownerId = 0) {\n    return this._decorationsTree.getAll(this, ownerId, false, false, true);\n  }\n  _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n    const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n    const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n    return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n  }\n  getRangeAt(start, end) {\n    return this._buffer.getRangeAt(start, end - start);\n  }\n  _changeDecorationImpl(decorationId, _range) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return;\n    }\n    if (node.options.after) {\n      const oldRange = this.getDecorationRange(decorationId);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n    }\n    if (node.options.before) {\n      const oldRange = this.getDecorationRange(decorationId);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n    }\n    const range = this._validateRangeRelaxedNoAllocations(_range);\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n    this._decorationsTree.delete(node);\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    this._decorationsTree.insert(node);\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n    if (node.options.after) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n    }\n    if (node.options.before) {\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n    }\n  }\n  _changeDecorationOptionsImpl(decorationId, options) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return;\n    }\n    const nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n    const nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n    this._onDidChangeDecorations.checkAffectedAndFire(options);\n    if (node.options.after || options.after) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n    }\n    if (node.options.before || options.before) {\n      const nodeRange = this._decorationsTree.getNodeRange(this, node);\n      this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n    }\n    const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n    const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n    if (movedInOverviewRuler || changedWhetherInjectedText) {\n      this._decorationsTree.delete(node);\n      node.setOptions(options);\n      this._decorationsTree.insert(node);\n    } else {\n      node.setOptions(options);\n    }\n  }\n  _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n    const versionId = this.getVersionId();\n    const oldDecorationsLen = oldDecorationsIds.length;\n    let oldDecorationIndex = 0;\n    const newDecorationsLen = newDecorations.length;\n    let newDecorationIndex = 0;\n    this._onDidChangeDecorations.beginDeferredEmit();\n    try {\n      const result = new Array(newDecorationsLen);\n      while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n        let node = null;\n        if (oldDecorationIndex < oldDecorationsLen) {\n          // (1) get ourselves an old node\n          do {\n            node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n          } while (!node && oldDecorationIndex < oldDecorationsLen);\n          // (2) remove the node from the tree (if it exists)\n          if (node) {\n            if (node.options.after) {\n              const nodeRange = this._decorationsTree.getNodeRange(this, node);\n              this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n            }\n            if (node.options.before) {\n              const nodeRange = this._decorationsTree.getNodeRange(this, node);\n              this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n            }\n            this._decorationsTree.delete(node);\n            if (!suppressEvents) {\n              this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n            }\n          }\n        }\n        if (newDecorationIndex < newDecorationsLen) {\n          // (3) create a new node if necessary\n          if (!node) {\n            const internalDecorationId = ++this._lastDecorationId;\n            const decorationId = `${this._instanceId};${internalDecorationId}`;\n            node = new IntervalNode(decorationId, 0, 0);\n            this._decorations[decorationId] = node;\n          }\n          // (4) initialize node\n          const newDecoration = newDecorations[newDecorationIndex];\n          const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n          const options = _normalizeOptions(newDecoration.options);\n          const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n          const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n          node.ownerId = ownerId;\n          node.reset(versionId, startOffset, endOffset, range);\n          node.setOptions(options);\n          if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n          }\n          if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n          }\n          if (!suppressEvents) {\n            this._onDidChangeDecorations.checkAffectedAndFire(options);\n          }\n          this._decorationsTree.insert(node);\n          result[newDecorationIndex] = node.id;\n          newDecorationIndex++;\n        } else {\n          if (node) {\n            delete this._decorations[node.id];\n          }\n        }\n      }\n      return result;\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  //#endregion\n  //#region Tokenization\n  // TODO move them to the tokenization part.\n  getLanguageId() {\n    return this.tokenization.getLanguageId();\n  }\n  setLanguage(languageIdOrSelection, source) {\n    if (typeof languageIdOrSelection === 'string') {\n      this._languageSelectionListener.clear();\n      this._setLanguage(languageIdOrSelection, source);\n    } else {\n      this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n      this._setLanguage(languageIdOrSelection.languageId, source);\n    }\n  }\n  _setLanguage(languageId, source) {\n    this.tokenization.setLanguageId(languageId, source);\n    this._languageService.requestRichLanguageFeatures(languageId);\n  }\n  getLanguageIdAtPosition(lineNumber, column) {\n    return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n  }\n  getWordAtPosition(position) {\n    return this._tokenizationTextModelPart.getWordAtPosition(position);\n  }\n  getWordUntilPosition(position) {\n    return this._tokenizationTextModelPart.getWordUntilPosition(position);\n  }\n  //#endregion\n  normalizePosition(position, affinity) {\n    return position;\n  }\n  /**\n   * Gets the column at which indentation stops at a given line.\n   * @internal\n  */\n  getLineIndentColumn(lineNumber) {\n    // Columns start with 1.\n    return indentOfLine(this.getLineContent(lineNumber)) + 1;\n  }\n}, TextModel_1 = _TextModel, _TextModel._MODEL_SYNC_LIMIT = 50 * 1024 * 1024, _TextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024, _TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000, _TextModel.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024, _TextModel.DEFAULT_CREATION_OPTIONS = {\n  isForSimpleWidget: false,\n  tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n  indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n  insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n  detectIndentation: false,\n  defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n  trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n  largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n  bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions\n}, _TextModel);\nTextModel = TextModel_1 = __decorate([__param(4, IUndoRedoService), __param(5, ILanguageService), __param(6, ILanguageConfigurationService), __param(7, IInstantiationService)], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n  let indent = 0;\n  for (const c of line) {\n    if (c === ' ' || c === '\\t') {\n      indent++;\n    } else {\n      break;\n    }\n  }\n  return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n  return node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n}\nfunction isOptionsInjectedText(options) {\n  return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n  return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n  constructor() {\n    this._decorationsTree0 = new IntervalTree();\n    this._decorationsTree1 = new IntervalTree();\n    this._injectedTextDecorationsTree = new IntervalTree();\n  }\n  ensureAllNodesHaveRanges(host) {\n    this.getAll(host, 0, false, false, false);\n  }\n  _ensureNodesHaveRanges(host, nodes) {\n    for (const node of nodes) {\n      if (node.range === null) {\n        node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n      }\n    }\n    return nodes;\n  }\n  getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n    const versionId = host.getVersionId();\n    const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n    return this._ensureNodesHaveRanges(host, result);\n  }\n  _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    return r0.concat(r1).concat(r2);\n  }\n  getInjectedTextInInterval(host, start, end, filterOwnerId) {\n    const versionId = host.getVersionId();\n    const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n  getAllInjectedText(host, filterOwnerId) {\n    const versionId = host.getVersionId();\n    const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n    return this._ensureNodesHaveRanges(host, result).filter(i => i.options.showIfCollapsed || !i.range.isEmpty());\n  }\n  getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n    const versionId = host.getVersionId();\n    const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n    return this._ensureNodesHaveRanges(host, result);\n  }\n  _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n    if (overviewRulerOnly) {\n      return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    } else {\n      const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n      const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n      const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n      return r0.concat(r1).concat(r2);\n    }\n  }\n  collectNodesFromOwner(ownerId) {\n    const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n    const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n    const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n    return r0.concat(r1).concat(r2);\n  }\n  collectNodesPostOrder() {\n    const r0 = this._decorationsTree0.collectNodesPostOrder();\n    const r1 = this._decorationsTree1.collectNodesPostOrder();\n    const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n    return r0.concat(r1).concat(r2);\n  }\n  insert(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.insert(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.insert(node);\n    } else {\n      this._decorationsTree0.insert(node);\n    }\n  }\n  delete(node) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.delete(node);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.delete(node);\n    } else {\n      this._decorationsTree0.delete(node);\n    }\n  }\n  getNodeRange(host, node) {\n    const versionId = host.getVersionId();\n    if (node.cachedVersionId !== versionId) {\n      this._resolveNode(node, versionId);\n    }\n    if (node.range === null) {\n      node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n    }\n    return node.range;\n  }\n  _resolveNode(node, cachedVersionId) {\n    if (isNodeInjectedText(node)) {\n      this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n    } else if (isNodeInOverviewRuler(node)) {\n      this._decorationsTree1.resolveNode(node, cachedVersionId);\n    } else {\n      this._decorationsTree0.resolveNode(node, cachedVersionId);\n    }\n  }\n  acceptReplace(offset, length, textLength, forceMoveMarkers) {\n    this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n  }\n}\nfunction cleanClassName(className) {\n  return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n  constructor(options) {\n    this.color = options.color || '';\n    this.darkColor = options.darkColor || '';\n  }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this._resolvedColor = null;\n    this.position = typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center;\n  }\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n    return this._resolvedColor;\n  }\n  invalidateCachedColor() {\n    this._resolvedColor = null;\n  }\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return color;\n    }\n    const c = color ? theme.getColor(color.id) : null;\n    if (!c) {\n      return '';\n    }\n    return c.toString();\n  }\n}\nexport class ModelDecorationGlyphMarginOptions {\n  constructor(options) {\n    this.position = options?.position ?? model.GlyphMarginLane.Center;\n    this.persistLane = options?.persistLane;\n  }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this.position = options.position;\n    this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n    this.sectionHeaderText = options.sectionHeaderText ?? null;\n  }\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n    return this._resolvedColor;\n  }\n  invalidateCachedColor() {\n    this._resolvedColor = undefined;\n  }\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return Color.fromHex(color);\n    }\n    return theme.getColor(color.id);\n  }\n}\nexport class ModelDecorationInjectedTextOptions {\n  static from(options) {\n    if (options instanceof ModelDecorationInjectedTextOptions) {\n      return options;\n    }\n    return new ModelDecorationInjectedTextOptions(options);\n  }\n  constructor(options) {\n    this.content = options.content || '';\n    this.inlineClassName = options.inlineClassName || null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.attachedData = options.attachedData || null;\n    this.cursorStops = options.cursorStops || null;\n  }\n}\nexport class ModelDecorationOptions {\n  static register(options) {\n    return new ModelDecorationOptions(options);\n  }\n  static createDynamic(options) {\n    return new ModelDecorationOptions(options);\n  }\n  constructor(options) {\n    this.description = options.description;\n    this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n    this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n    this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n    this.blockPadding = options.blockPadding ?? null;\n    this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n    this.zIndex = options.zIndex || 0;\n    this.className = options.className ? cleanClassName(options.className) : null;\n    this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n    this.hoverMessage = options.hoverMessage || null;\n    this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n    this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n    this.isWholeLine = options.isWholeLine || false;\n    this.showIfCollapsed = options.showIfCollapsed || false;\n    this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n    this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n    this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n    this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n    this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n    this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n    this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n    this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n    this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n    this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n    this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n    this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n    this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n    this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n    this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n    this.hideInStringTokens = options.hideInStringTokens ?? false;\n  }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({\n  description: 'empty'\n});\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [ModelDecorationOptions.register({\n  description: 'tracked-range-always-grows-when-typing-at-edges',\n  stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-never-grows-when-typing-at-edges',\n  stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-before',\n  stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */\n}), ModelDecorationOptions.register({\n  description: 'tracked-range-grows-only-when-typing-after',\n  stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */\n})];\nfunction _normalizeOptions(options) {\n  if (options instanceof ModelDecorationOptions) {\n    return options;\n  }\n  return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n  constructor(handleBeforeFire) {\n    super();\n    this.handleBeforeFire = handleBeforeFire;\n    this._actual = this._register(new Emitter());\n    this.event = this._actual.event;\n    this._affectedInjectedTextLines = null;\n    this._deferredCnt = 0;\n    this._shouldFireDeferred = false;\n    this._affectsMinimap = false;\n    this._affectsOverviewRuler = false;\n    this._affectsGlyphMargin = false;\n    this._affectsLineNumber = false;\n  }\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n  endDeferredEmit() {\n    this._deferredCnt--;\n    if (this._deferredCnt === 0) {\n      if (this._shouldFireDeferred) {\n        this.doFire();\n      }\n      this._affectedInjectedTextLines?.clear();\n      this._affectedInjectedTextLines = null;\n    }\n  }\n  recordLineAffectedByInjectedText(lineNumber) {\n    if (!this._affectedInjectedTextLines) {\n      this._affectedInjectedTextLines = new Set();\n    }\n    this._affectedInjectedTextLines.add(lineNumber);\n  }\n  checkAffectedAndFire(options) {\n    this._affectsMinimap ||= !!options.minimap?.position;\n    this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n    this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n    this._affectsLineNumber ||= !!options.lineNumberClassName;\n    this.tryFire();\n  }\n  fire() {\n    this._affectsMinimap = true;\n    this._affectsOverviewRuler = true;\n    this._affectsGlyphMargin = true;\n    this.tryFire();\n  }\n  tryFire() {\n    if (this._deferredCnt === 0) {\n      this.doFire();\n    } else {\n      this._shouldFireDeferred = true;\n    }\n  }\n  doFire() {\n    this.handleBeforeFire(this._affectedInjectedTextLines);\n    const event = {\n      affectsMinimap: this._affectsMinimap,\n      affectsOverviewRuler: this._affectsOverviewRuler,\n      affectsGlyphMargin: this._affectsGlyphMargin,\n      affectsLineNumber: this._affectsLineNumber\n    };\n    this._shouldFireDeferred = false;\n    this._affectsMinimap = false;\n    this._affectsOverviewRuler = false;\n    this._affectsGlyphMargin = false;\n    this._actual.fire(event);\n  }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n  constructor() {\n    super();\n    /**\n     * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n     */\n    this._fastEmitter = this._register(new Emitter());\n    this.fastEvent = this._fastEmitter.event;\n    this._slowEmitter = this._register(new Emitter());\n    this.slowEvent = this._slowEmitter.event;\n    this._deferredCnt = 0;\n    this._deferredEvent = null;\n  }\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n  endDeferredEmit(resultingSelection = null) {\n    this._deferredCnt--;\n    if (this._deferredCnt === 0) {\n      if (this._deferredEvent !== null) {\n        this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n        const e = this._deferredEvent;\n        this._deferredEvent = null;\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n      }\n    }\n  }\n  fire(e) {\n    if (this._deferredCnt > 0) {\n      if (this._deferredEvent) {\n        this._deferredEvent = this._deferredEvent.merge(e);\n      } else {\n        this._deferredEvent = e;\n      }\n      return;\n    }\n    this._fastEmitter.fire(e);\n    this._slowEmitter.fire(e);\n  }\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","TextModel_1","ArrayQueue","pushMany","Color","BugIndicatingError","illegalArgument","onUnexpectedError","Emitter","Disposable","MutableDisposable","combinedDisposable","strings","URI","countEOL","normalizeIndentation","Position","Range","Selection","EDITOR_MODEL_DEFAULTS","ILanguageService","ILanguageConfigurationService","model","BracketPairsTextModelPart","ColorizedBracketPairsDecorationProvider","EditStack","GuidesTextModelPart","guessIndentation","IntervalNode","IntervalTree","recomputeMaxEnd","PieceTreeTextBuffer","PieceTreeTextBufferBuilder","SearchParams","TextModelSearch","TokenizationTextModelPart","AttachedViews","InternalModelContentChangeEvent","LineInjectedText","ModelInjectedTextChangedEvent","ModelRawContentChangedEvent","ModelRawEOLChanged","ModelRawFlush","ModelRawLineChanged","ModelRawLinesDeleted","ModelRawLinesInserted","IInstantiationService","IUndoRedoService","createTextBufferFactory","text","builder","acceptChunk","finish","createTextBufferFactoryFromSnapshot","snapshot","chunk","read","createTextBuffer","value","defaultEOL","factory","isITextSnapshot","create","MODEL_ID","LIMIT_FIND_COUNT","LONG_LINE_BOUNDARY","TextModelSnapshot","constructor","source","_source","_eos","result","resultCnt","resultLength","tmp","join","invalidFunc","Error","TextModel","_TextModel","resolveOptions","textBuffer","options","detectIndentation","guessedIndentation","tabSize","insertSpaces","TextModelResolvedOptions","indentSize","trimAutoWhitespace","bracketPairColorizationOptions","onDidChangeLanguage","_tokenizationTextModelPart","onDidChangeLanguageConfiguration","onDidChangeTokens","onDidChangeContent","listener","_eventEmitter","slowEvent","e","contentChangedEvent","onDidChangeContentOrInjectedText","fastEvent","_onDidChangeInjectedText","event","_isDisposing","__isDisposing","tokenization","bracketPairs","_bracketPairs","guides","_guidesTextModelPart","languageIdOrSelection","creationOptions","associatedResource","_undoRedoService","_languageService","_languageConfigurationService","instantiationService","_onWillDispose","_register","onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","DidChangeContentEmitter","_languageSelectionListener","_deltaDecorationCallCnt","_attachedViews","id","isForSimpleWidget","_associatedResource","parse","_attachedEditorCount","disposable","_buffer","_bufferDisposable","_options","languageId","onDidChange","_setLanguage","_decorationProvider","createInstance","bufferLineCount","getLineCount","bufferTextLength","getValueLengthInRange","getLineLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForHeapOperation","LARGE_FILE_HEAP_OPERATION_THRESHOLD","_isTooLargeForSyncing","_MODEL_SYNC_LIMIT","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_isDisposed","_instanceId","singleLetterHash","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","beginDeferredEmit","fire","endDeferredEmit","requestRichLanguageFeatures","handleLanguageConfigurationServiceChange","dispose","emptyDisposedTextBuffer","None","_assertNotDisposed","_emitContentChangedEvent","rawChange","change","handleDidChangeContent","setValue","undefined","_setValueFromTextBuffer","_createContentChanged2","range","rangeOffset","rangeLength","isUndoing","isRedoing","isFlush","isEolChange","changes","eol","getEOL","versionId","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","endLineNumber","endColumn","getLineMaxColumn","_increaseVersionId","clear","getValue","setEOL","newEOL","_onBeforeEOLChange","_onAfterEOLChange","ensureAllNodesHaveRanges","allDecorations","collectNodesPostOrder","len","node","delta","cachedAbsoluteStart","start","startOffset","getOffsetAt","startLineNumber","startColumn","endOffset","cachedAbsoluteEnd","cachedVersionId","end","onBeforeAttached","handleDidChangeAttached","attachView","onBeforeDetached","view","detachView","isAttachedToEditor","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForTokenization","isTooLargeForHeapOperation","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineCount","lineNumber","lineLength","uri","getOptions","getFormattingOptions","updateOptions","_newOpts","originalIndentSize","bracketColorizationOptions","newOpts","equals","createChangeEvent","handleDidChangeOptions","defaultInsertSpaces","defaultTabSize","str","mightContainRTL","mightContainUnusualLineTerminators","removeUnusualLineTerminators","selections","matches","findMatches","UNUSUAL_LINE_TERMINATORS","resetMightContainUnusualLineTerminators","pushEditOperations","map","m","mightContainNonBasicASCII","getAlternativeVersionId","getInitialUndoRedoSnapshot","rawPosition","position","_validatePosition","column","getPositionAt","rawOffset","offset","Math","min","getLength","max","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","preserveBOM","fullModelRange","fullModelValue","getValueInRange","getBOM","createSnapshot","getValueLength","rawRange","validateRange","getCharacterCountInRange","getLineContent","getLinesContent","getEndOfLineSequence","getLineMinColumn","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","_validateRangeRelaxedNoAllocations","linesCount","initialStartLineNumber","initialStartColumn","floor","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","charCodeBefore","getLineCharCode","isHighSurrogate","_lineNumber","_column","validatePosition","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","modifyPosition","candidate","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","searchString","rawSearchScope","isRegex","matchCase","wordSeparators","searchRanges","Array","isArray","every","searchScope","isIRange","sort","d1","d2","uniqueSearchRanges","push","reduce","prev","curr","areIntersecting","plusRange","matchMapper","indexOf","searchParams","parseSearchRequest","arr","concat","findNextMatch","rawSearchStart","searchStart","ret","findPreviousMatch","pushStackElement","popStackElement","pushEOL","currentEOL","_validateEditOperation","rawOperation","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","_validateEditOperations","rawOperations","beforeCursorState","editOperations","cursorStateComputer","group","_pushEditOperations","incomingEdits","op","editsAreNearCursors","sel","foundEditNearSel","j","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","isEmpty","charAt","trimRange","pushEditOperation","_applyUndo","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","rangeEnd","newEnd","oldText","_applyUndoRedoEdits","_applyRedo","oldPosition","oldEnd","newText","applyEdits","computeUndoEdits","operations","_doApplyEdits","oldLineCount","newLineCount","contentChanges","trimAutoWhitespaceLineNumbers","acceptReplace","rawContentChanges","eolCount","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","fromDecorations","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","cnt","fromLineNumber","injectedTexts","newLines","takeWhile","reverseEdits","undo","canUndo","redo","canRedo","size","affectedLines","from","lineChangeEvents","_getInjectedTextInLine","changeDecorations","callback","ownerId","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","newRange","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","delete","reset","setOptions","insert","removeAllDecorationsWithOwnerId","nodes","collectNodesFromOwner","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","onlyMarginDecorations","decorations","_getDecorationsInRange","getDecorationsInRange","onlyMinimapDecorations","validatedRange","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","filter","t","getAllDecorations","getAllMarginDecorations","filterRange","filterOwnerId","getAllInInterval","getRangeAt","after","oldRange","recordLineAffectedByInjectedText","before","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","color","nodeIsInOverviewRuler","nodeRange","movedInOverviewRuler","changedWhetherInjectedText","isOptionsInjectedText","isNodeInjectedText","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","getLanguageId","setLanguage","setLanguageId","getLanguageIdAtPosition","getWordAtPosition","getWordUntilPosition","normalizePosition","affinity","getLineIndentColumn","indentOfLine","DEFAULT_CREATION_OPTIONS","line","indent","isNodeInOverviewRuler","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","intervalSearch","r1","r2","showIfCollapsed","search","overviewRulerOnly","_search","_resolveNode","resolveNode","textLength","cleanClassName","className","replace","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","OverviewRulerLane","Center","getColor","theme","type","_resolveColor","invalidateCachedColor","toString","ModelDecorationGlyphMarginOptions","GlyphMarginLane","persistLane","ModelDecorationMinimapOptions","sectionHeaderStyle","sectionHeaderText","fromHex","ModelDecorationInjectedTextOptions","content","inlineClassName","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","register","createDynamic","description","blockClassName","blockDoesNotCollapse","blockIsAfterEnd","blockPadding","stickiness","zIndex","shouldFillLineOnLineBreak","hoverMessage","glyphMarginHoverMessage","lineNumberHoverMessage","isWholeLine","collapseOnReplaceEdit","minimap","glyphMargin","glyphMarginClassName","linesDecorationsClassName","lineNumberClassName","linesDecorationsTooltip","htmlAttributeEncodeValue","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","EMPTY","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFireDeferred","_affectsMinimap","_affectsOverviewRuler","_affectsGlyphMargin","_affectsLineNumber","doFire","Set","add","tryFire","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","affectsLineNumber","_fastEmitter","_slowEmitter","_deferredEvent","rawContentChangedEvent","merge"],"sources":["P:/IDEA/JudgeX/judgex_front/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? model.GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}