{"ast":null,"code":"var _AbstractGotoSymbolQuickAccessProvider;\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar AbstractGotoSymbolQuickAccessProvider_1;\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SymbolKinds, getAriaLabelForSymbol } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { findLast } from '../../../../base/common/arraysFind.js';\nlet AbstractGotoSymbolQuickAccessProvider = (_AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n  constructor(_languageFeaturesService, _outlineModelService, options = Object.create(null)) {\n    super(options);\n    this._languageFeaturesService = _languageFeaturesService;\n    this._outlineModelService = _outlineModelService;\n    this.options = options;\n    this.options.canAcceptInBackground = true;\n  }\n  provideWithoutTextEditor(picker) {\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n    return Disposable.None;\n  }\n  provideWithTextEditor(context, picker, token, runOptions) {\n    const editor = context.editor;\n    const model = this.getModel(editor);\n    if (!model) {\n      return Disposable.None;\n    }\n    // Provide symbols from model if available in registry\n    if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n      return this.doProvideWithEditorSymbols(context, model, picker, token, runOptions);\n    }\n    // Otherwise show an entry for a model without registry\n    // But give a chance to resolve the symbols at a later\n    // point if possible\n    return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n  }\n  doProvideWithoutEditorSymbols(context, model, picker, token) {\n    const disposables = new DisposableStore();\n    // Generic pick for not having any symbol information\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n    // Wait for changes to the registry and see if eventually\n    // we do get symbols. This can happen if the picker is opened\n    // very early after the model has loaded but before the\n    // language registry is ready.\n    // https://github.com/microsoft/vscode/issues/70607\n    (async () => {\n      const result = await this.waitForLanguageSymbolRegistry(model, disposables);\n      if (!result || token.isCancellationRequested) {\n        return;\n      }\n      disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n    })();\n    return disposables;\n  }\n  provideLabelPick(picker, label) {\n    picker.items = [{\n      label,\n      index: 0,\n      kind: 14 /* SymbolKind.String */\n    }];\n    picker.ariaLabel = label;\n  }\n  async waitForLanguageSymbolRegistry(model, disposables) {\n    if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n      return true;\n    }\n    const symbolProviderRegistryPromise = new DeferredPromise();\n    // Resolve promise when registry knows model\n    const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n      if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n        symbolProviderListener.dispose();\n        symbolProviderRegistryPromise.complete(true);\n      }\n    }));\n    // Resolve promise when we get disposed too\n    disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n    return symbolProviderRegistryPromise.p;\n  }\n  doProvideWithEditorSymbols(context, model, picker, token, runOptions) {\n    const editor = context.editor;\n    const disposables = new DisposableStore();\n    // Goto symbol once picked\n    disposables.add(picker.onDidAccept(event => {\n      const [item] = picker.selectedItems;\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          preserveFocus: event.inBackground\n        });\n        runOptions?.handleAccept?.(item);\n        if (!event.inBackground) {\n          picker.hide();\n        }\n      }\n    }));\n    // Goto symbol side by side if enabled\n    disposables.add(picker.onDidTriggerItemButton(({\n      item\n    }) => {\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          forceSideBySide: true\n        });\n        picker.hide();\n      }\n    }));\n    // Resolve symbols from document once and reuse this\n    // request for all filtering and typing then on\n    const symbolsPromise = this.getDocumentSymbols(model, token);\n    // Set initial picks and update on type\n    let picksCts = undefined;\n    const updatePickerItems = async positionToEnclose => {\n      // Cancel any previous ask for picks and busy\n      picksCts?.dispose(true);\n      picker.busy = false;\n      // Create new cancellation source for this run\n      picksCts = new CancellationTokenSource(token);\n      // Collect symbol picks\n      picker.busy = true;\n      try {\n        const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());\n        const items = await this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token, model);\n        if (token.isCancellationRequested) {\n          return;\n        }\n        if (items.length > 0) {\n          picker.items = items;\n          if (positionToEnclose && query.original.length === 0) {\n            const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));\n            if (candidate) {\n              picker.activeItems = [candidate];\n            }\n          }\n        } else {\n          if (query.original.length > 0) {\n            this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n          } else {\n            this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n          }\n        }\n      } finally {\n        if (!token.isCancellationRequested) {\n          picker.busy = false;\n        }\n      }\n    };\n    disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));\n    updatePickerItems(editor.getSelection()?.getPosition());\n    // Reveal and decorate when active item changes\n    disposables.add(picker.onDidChangeActive(() => {\n      const [item] = picker.activeItems;\n      if (item && item.range) {\n        // Reveal\n        editor.revealRangeInCenter(item.range.selection, 0 /* ScrollType.Smooth */);\n        // Decorate\n        this.addDecorations(editor, item.range.decoration);\n      }\n    }));\n    return disposables;\n  }\n  async doGetSymbolPicks(symbolsPromise, query, options, token, model) {\n    const symbols = await symbolsPromise;\n    if (token.isCancellationRequested) {\n      return [];\n    }\n    const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;\n    const filterPos = filterBySymbolKind ? 1 : 0;\n    // Split between symbol and container query\n    let symbolQuery;\n    let containerQuery;\n    if (query.values && query.values.length > 1) {\n      symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n      containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n    } else {\n      symbolQuery = query;\n    }\n    // Convert to symbol picks and apply filtering\n    let buttons;\n    const openSideBySideDirection = this.options?.openSideBySideDirection?.();\n    if (openSideBySideDirection) {\n      buttons = [{\n        iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),\n        tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n      }];\n    }\n    const filteredSymbolPicks = [];\n    for (let index = 0; index < symbols.length; index++) {\n      const symbol = symbols[index];\n      const symbolLabel = trim(symbol.name);\n      const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n      const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n      let containerLabel = symbol.containerName;\n      if (options?.extraContainerLabel) {\n        if (containerLabel) {\n          containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n        } else {\n          containerLabel = options.extraContainerLabel;\n        }\n      }\n      let symbolScore = undefined;\n      let symbolMatches = undefined;\n      let containerScore = undefined;\n      let containerMatches = undefined;\n      if (query.original.length > filterPos) {\n        // First: try to score on the entire query, it is possible that\n        // the symbol matches perfectly (e.g. searching for \"change log\"\n        // can be a match on a markdown symbol \"change log\"). In that\n        // case we want to skip the container query altogether.\n        let skipContainerQuery = false;\n        if (symbolQuery !== query) {\n          [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, {\n            ...query,\n            values: undefined /* disable multi-query support */\n          }, filterPos, symbolLabelIconOffset);\n          if (typeof symbolScore === 'number') {\n            skipContainerQuery = true; // since we consumed the query, skip any container matching\n          }\n        }\n        // Otherwise: score on the symbol query and match on the container later\n        if (typeof symbolScore !== 'number') {\n          [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n          if (typeof symbolScore !== 'number') {\n            continue;\n          }\n        }\n        // Score by container if specified\n        if (!skipContainerQuery && containerQuery) {\n          if (containerLabel && containerQuery.original.length > 0) {\n            [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n          }\n          if (typeof containerScore !== 'number') {\n            continue;\n          }\n          if (typeof symbolScore === 'number') {\n            symbolScore += containerScore; // boost symbolScore by containerScore\n          }\n        }\n      }\n      const deprecated = symbol.tags && symbol.tags.indexOf(1 /* SymbolTag.Deprecated */) >= 0;\n      filteredSymbolPicks.push({\n        index,\n        kind: symbol.kind,\n        score: symbolScore,\n        label: symbolLabelWithIcon,\n        ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),\n        description: containerLabel,\n        highlights: deprecated ? undefined : {\n          label: symbolMatches,\n          description: containerMatches\n        },\n        range: {\n          selection: Range.collapseToStart(symbol.selectionRange),\n          decoration: symbol.range\n        },\n        uri: model.uri,\n        symbolName: symbolLabel,\n        strikethrough: deprecated,\n        buttons\n      });\n    }\n    // Sort by score\n    const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB));\n    // Add separator for types\n    // - @  only total number of symbols\n    // - @: grouped by symbol kind\n    let symbolPicks = [];\n    if (filterBySymbolKind) {\n      let lastSymbolKind = undefined;\n      let lastSeparator = undefined;\n      let lastSymbolKindCounter = 0;\n      function updateLastSeparatorLabel() {\n        if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n          lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n        }\n      }\n      for (const symbolPick of sortedFilteredSymbolPicks) {\n        // Found new kind\n        if (lastSymbolKind !== symbolPick.kind) {\n          // Update last separator with number of symbols we found for kind\n          updateLastSeparatorLabel();\n          lastSymbolKind = symbolPick.kind;\n          lastSymbolKindCounter = 1;\n          // Add new separator for new kind\n          lastSeparator = {\n            type: 'separator'\n          };\n          symbolPicks.push(lastSeparator);\n        }\n        // Existing kind, keep counting\n        else {\n          lastSymbolKindCounter++;\n        }\n        // Add to final result\n        symbolPicks.push(symbolPick);\n      }\n      // Update last separator with number of symbols we found for kind\n      updateLastSeparatorLabel();\n    } else if (sortedFilteredSymbolPicks.length > 0) {\n      symbolPicks = [{\n        label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length),\n        type: 'separator'\n      }, ...sortedFilteredSymbolPicks];\n    }\n    return symbolPicks;\n  }\n  compareByScore(symbolA, symbolB) {\n    if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n      return 1;\n    } else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n      return -1;\n    }\n    if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n      if (symbolA.score > symbolB.score) {\n        return -1;\n      } else if (symbolA.score < symbolB.score) {\n        return 1;\n      }\n    }\n    if (symbolA.index < symbolB.index) {\n      return -1;\n    } else if (symbolA.index > symbolB.index) {\n      return 1;\n    }\n    return 0;\n  }\n  compareByKindAndScore(symbolA, symbolB) {\n    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    // Sort by type first if scoped search\n    const result = kindA.localeCompare(kindB);\n    if (result === 0) {\n      return this.compareByScore(symbolA, symbolB);\n    }\n    return result;\n  }\n  async getDocumentSymbols(document, token) {\n    const model = await this._outlineModelService.getOrCreate(document, token);\n    return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n  }\n}, AbstractGotoSymbolQuickAccessProvider_1 = _AbstractGotoSymbolQuickAccessProvider, _AbstractGotoSymbolQuickAccessProvider.PREFIX = '@', _AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':', _AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${_AbstractGotoSymbolQuickAccessProvider.PREFIX}${_AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`, _AbstractGotoSymbolQuickAccessProvider);\nAbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = __decorate([__param(0, ILanguageFeaturesService), __param(1, IOutlineModelService)], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n  [5 /* SymbolKind.Method */]: localize('method', \"methods ({0})\"),\n  [11 /* SymbolKind.Function */]: localize('function', \"functions ({0})\"),\n  [8 /* SymbolKind.Constructor */]: localize('_constructor', \"constructors ({0})\"),\n  [12 /* SymbolKind.Variable */]: localize('variable', \"variables ({0})\"),\n  [4 /* SymbolKind.Class */]: localize('class', \"classes ({0})\"),\n  [22 /* SymbolKind.Struct */]: localize('struct', \"structs ({0})\"),\n  [23 /* SymbolKind.Event */]: localize('event', \"events ({0})\"),\n  [24 /* SymbolKind.Operator */]: localize('operator', \"operators ({0})\"),\n  [10 /* SymbolKind.Interface */]: localize('interface', \"interfaces ({0})\"),\n  [2 /* SymbolKind.Namespace */]: localize('namespace', \"namespaces ({0})\"),\n  [3 /* SymbolKind.Package */]: localize('package', \"packages ({0})\"),\n  [25 /* SymbolKind.TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n  [1 /* SymbolKind.Module */]: localize('modules', \"modules ({0})\"),\n  [6 /* SymbolKind.Property */]: localize('property', \"properties ({0})\"),\n  [9 /* SymbolKind.Enum */]: localize('enum', \"enumerations ({0})\"),\n  [21 /* SymbolKind.EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n  [14 /* SymbolKind.String */]: localize('string', \"strings ({0})\"),\n  [0 /* SymbolKind.File */]: localize('file', \"files ({0})\"),\n  [17 /* SymbolKind.Array */]: localize('array', \"arrays ({0})\"),\n  [15 /* SymbolKind.Number */]: localize('number', \"numbers ({0})\"),\n  [16 /* SymbolKind.Boolean */]: localize('boolean', \"booleans ({0})\"),\n  [18 /* SymbolKind.Object */]: localize('object', \"objects ({0})\"),\n  [19 /* SymbolKind.Key */]: localize('key', \"keys ({0})\"),\n  [7 /* SymbolKind.Field */]: localize('field', \"fields ({0})\"),\n  [13 /* SymbolKind.Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","AbstractGotoSymbolQuickAccessProvider_1","DeferredPromise","CancellationTokenSource","Codicon","ThemeIcon","pieceToQuery","prepareQuery","scoreFuzzy2","Disposable","DisposableStore","toDisposable","format","trim","Range","SymbolKinds","getAriaLabelForSymbol","IOutlineModelService","AbstractEditorNavigationQuickAccessProvider","localize","ILanguageFeaturesService","findLast","AbstractGotoSymbolQuickAccessProvider","_AbstractGotoSymbolQuickAccessProvider","constructor","_languageFeaturesService","_outlineModelService","options","create","canAcceptInBackground","provideWithoutTextEditor","picker","provideLabelPick","None","provideWithTextEditor","context","token","runOptions","editor","model","getModel","documentSymbolProvider","has","doProvideWithEditorSymbols","doProvideWithoutEditorSymbols","disposables","result","waitForLanguageSymbolRegistry","isCancellationRequested","add","label","items","index","kind","ariaLabel","symbolProviderRegistryPromise","symbolProviderListener","onDidChange","dispose","complete","p","onDidAccept","event","item","selectedItems","range","gotoLocation","selection","keyMods","preserveFocus","inBackground","handleAccept","hide","onDidTriggerItemButton","forceSideBySide","symbolsPromise","getDocumentSymbols","picksCts","undefined","updatePickerItems","positionToEnclose","busy","query","value","substr","PREFIX","doGetSymbolPicks","original","candidate","Boolean","type","containsPosition","decoration","activeItems","onDidChangeValue","getSelection","getPosition","onDidChangeActive","revealRangeInCenter","addDecorations","symbols","filterBySymbolKind","indexOf","SCOPE_PREFIX","filterPos","symbolQuery","containerQuery","values","slice","buttons","openSideBySideDirection","iconClass","asClassName","splitHorizontal","splitVertical","tooltip","filteredSymbolPicks","symbol","symbolLabel","name","symbolLabelWithIcon","toIcon","id","symbolLabelIconOffset","containerLabel","containerName","extraContainerLabel","symbolScore","symbolMatches","containerScore","containerMatches","skipContainerQuery","deprecated","tags","push","score","description","highlights","collapseToStart","selectionRange","uri","symbolName","strikethrough","sortedFilteredSymbolPicks","sort","symbolA","symbolB","compareByKindAndScore","compareByScore","symbolPicks","lastSymbolKind","lastSeparator","lastSymbolKindCounter","updateLastSeparatorLabel","NLS_SYMBOL_KIND_CACHE","FALLBACK_NLS_SYMBOL_KIND","symbolPick","kindA","kindB","localeCompare","document","getOrCreate","asListOfDocumentSymbols","PREFIX_BY_CATEGORY"],"sources":["P:/IDEA/JudgeX/judgex_front/node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar AbstractGotoSymbolQuickAccessProvider_1;\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Codicon } from '../../../../base/common/codicons.js';\nimport { ThemeIcon } from '../../../../base/common/themables.js';\nimport { pieceToQuery, prepareQuery, scoreFuzzy2 } from '../../../../base/common/fuzzyScorer.js';\nimport { Disposable, DisposableStore, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { format, trim } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { SymbolKinds, getAriaLabelForSymbol } from '../../../common/languages.js';\nimport { IOutlineModelService } from '../../documentSymbols/browser/outlineModel.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { localize } from '../../../../nls.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { findLast } from '../../../../base/common/arraysFind.js';\nlet AbstractGotoSymbolQuickAccessProvider = class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n    static { AbstractGotoSymbolQuickAccessProvider_1 = this; }\n    static { this.PREFIX = '@'; }\n    static { this.SCOPE_PREFIX = ':'; }\n    static { this.PREFIX_BY_CATEGORY = `${this.PREFIX}${this.SCOPE_PREFIX}`; }\n    constructor(_languageFeaturesService, _outlineModelService, options = Object.create(null)) {\n        super(options);\n        this._languageFeaturesService = _languageFeaturesService;\n        this._outlineModelService = _outlineModelService;\n        this.options = options;\n        this.options.canAcceptInBackground = true;\n    }\n    provideWithoutTextEditor(picker) {\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n        return Disposable.None;\n    }\n    provideWithTextEditor(context, picker, token, runOptions) {\n        const editor = context.editor;\n        const model = this.getModel(editor);\n        if (!model) {\n            return Disposable.None;\n        }\n        // Provide symbols from model if available in registry\n        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n            return this.doProvideWithEditorSymbols(context, model, picker, token, runOptions);\n        }\n        // Otherwise show an entry for a model without registry\n        // But give a chance to resolve the symbols at a later\n        // point if possible\n        return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n    }\n    doProvideWithoutEditorSymbols(context, model, picker, token) {\n        const disposables = new DisposableStore();\n        // Generic pick for not having any symbol information\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n        // Wait for changes to the registry and see if eventually\n        // we do get symbols. This can happen if the picker is opened\n        // very early after the model has loaded but before the\n        // language registry is ready.\n        // https://github.com/microsoft/vscode/issues/70607\n        (async () => {\n            const result = await this.waitForLanguageSymbolRegistry(model, disposables);\n            if (!result || token.isCancellationRequested) {\n                return;\n            }\n            disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n        })();\n        return disposables;\n    }\n    provideLabelPick(picker, label) {\n        picker.items = [{ label, index: 0, kind: 14 /* SymbolKind.String */ }];\n        picker.ariaLabel = label;\n    }\n    async waitForLanguageSymbolRegistry(model, disposables) {\n        if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n            return true;\n        }\n        const symbolProviderRegistryPromise = new DeferredPromise();\n        // Resolve promise when registry knows model\n        const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {\n            if (this._languageFeaturesService.documentSymbolProvider.has(model)) {\n                symbolProviderListener.dispose();\n                symbolProviderRegistryPromise.complete(true);\n            }\n        }));\n        // Resolve promise when we get disposed too\n        disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));\n        return symbolProviderRegistryPromise.p;\n    }\n    doProvideWithEditorSymbols(context, model, picker, token, runOptions) {\n        const editor = context.editor;\n        const disposables = new DisposableStore();\n        // Goto symbol once picked\n        disposables.add(picker.onDidAccept(event => {\n            const [item] = picker.selectedItems;\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });\n                runOptions?.handleAccept?.(item);\n                if (!event.inBackground) {\n                    picker.hide();\n                }\n            }\n        }));\n        // Goto symbol side by side if enabled\n        disposables.add(picker.onDidTriggerItemButton(({ item }) => {\n            if (item && item.range) {\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });\n                picker.hide();\n            }\n        }));\n        // Resolve symbols from document once and reuse this\n        // request for all filtering and typing then on\n        const symbolsPromise = this.getDocumentSymbols(model, token);\n        // Set initial picks and update on type\n        let picksCts = undefined;\n        const updatePickerItems = async (positionToEnclose) => {\n            // Cancel any previous ask for picks and busy\n            picksCts?.dispose(true);\n            picker.busy = false;\n            // Create new cancellation source for this run\n            picksCts = new CancellationTokenSource(token);\n            // Collect symbol picks\n            picker.busy = true;\n            try {\n                const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());\n                const items = await this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token, model);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                if (items.length > 0) {\n                    picker.items = items;\n                    if (positionToEnclose && query.original.length === 0) {\n                        const candidate = findLast(items, item => Boolean(item.type !== 'separator' && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));\n                        if (candidate) {\n                            picker.activeItems = [candidate];\n                        }\n                    }\n                }\n                else {\n                    if (query.original.length > 0) {\n                        this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n                    }\n                    else {\n                        this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n                    }\n                }\n            }\n            finally {\n                if (!token.isCancellationRequested) {\n                    picker.busy = false;\n                }\n            }\n        };\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems(undefined)));\n        updatePickerItems(editor.getSelection()?.getPosition());\n        // Reveal and decorate when active item changes\n        disposables.add(picker.onDidChangeActive(() => {\n            const [item] = picker.activeItems;\n            if (item && item.range) {\n                // Reveal\n                editor.revealRangeInCenter(item.range.selection, 0 /* ScrollType.Smooth */);\n                // Decorate\n                this.addDecorations(editor, item.range.decoration);\n            }\n        }));\n        return disposables;\n    }\n    async doGetSymbolPicks(symbolsPromise, query, options, token, model) {\n        const symbols = await symbolsPromise;\n        if (token.isCancellationRequested) {\n            return [];\n        }\n        const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;\n        const filterPos = filterBySymbolKind ? 1 : 0;\n        // Split between symbol and container query\n        let symbolQuery;\n        let containerQuery;\n        if (query.values && query.values.length > 1) {\n            symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n            containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n        }\n        else {\n            symbolQuery = query;\n        }\n        // Convert to symbol picks and apply filtering\n        let buttons;\n        const openSideBySideDirection = this.options?.openSideBySideDirection?.();\n        if (openSideBySideDirection) {\n            buttons = [{\n                    iconClass: openSideBySideDirection === 'right' ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),\n                    tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n                }];\n        }\n        const filteredSymbolPicks = [];\n        for (let index = 0; index < symbols.length; index++) {\n            const symbol = symbols[index];\n            const symbolLabel = trim(symbol.name);\n            const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;\n            const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n            let containerLabel = symbol.containerName;\n            if (options?.extraContainerLabel) {\n                if (containerLabel) {\n                    containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;\n                }\n                else {\n                    containerLabel = options.extraContainerLabel;\n                }\n            }\n            let symbolScore = undefined;\n            let symbolMatches = undefined;\n            let containerScore = undefined;\n            let containerMatches = undefined;\n            if (query.original.length > filterPos) {\n                // First: try to score on the entire query, it is possible that\n                // the symbol matches perfectly (e.g. searching for \"change log\"\n                // can be a match on a markdown symbol \"change log\"). In that\n                // case we want to skip the container query altogether.\n                let skipContainerQuery = false;\n                if (symbolQuery !== query) {\n                    [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, { ...query, values: undefined /* disable multi-query support */ }, filterPos, symbolLabelIconOffset);\n                    if (typeof symbolScore === 'number') {\n                        skipContainerQuery = true; // since we consumed the query, skip any container matching\n                    }\n                }\n                // Otherwise: score on the symbol query and match on the container later\n                if (typeof symbolScore !== 'number') {\n                    [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n                    if (typeof symbolScore !== 'number') {\n                        continue;\n                    }\n                }\n                // Score by container if specified\n                if (!skipContainerQuery && containerQuery) {\n                    if (containerLabel && containerQuery.original.length > 0) {\n                        [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n                    }\n                    if (typeof containerScore !== 'number') {\n                        continue;\n                    }\n                    if (typeof symbolScore === 'number') {\n                        symbolScore += containerScore; // boost symbolScore by containerScore\n                    }\n                }\n            }\n            const deprecated = symbol.tags && symbol.tags.indexOf(1 /* SymbolTag.Deprecated */) >= 0;\n            filteredSymbolPicks.push({\n                index,\n                kind: symbol.kind,\n                score: symbolScore,\n                label: symbolLabelWithIcon,\n                ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),\n                description: containerLabel,\n                highlights: deprecated ? undefined : {\n                    label: symbolMatches,\n                    description: containerMatches\n                },\n                range: {\n                    selection: Range.collapseToStart(symbol.selectionRange),\n                    decoration: symbol.range\n                },\n                uri: model.uri,\n                symbolName: symbolLabel,\n                strikethrough: deprecated,\n                buttons\n            });\n        }\n        // Sort by score\n        const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ?\n            this.compareByKindAndScore(symbolA, symbolB) :\n            this.compareByScore(symbolA, symbolB));\n        // Add separator for types\n        // - @  only total number of symbols\n        // - @: grouped by symbol kind\n        let symbolPicks = [];\n        if (filterBySymbolKind) {\n            let lastSymbolKind = undefined;\n            let lastSeparator = undefined;\n            let lastSymbolKindCounter = 0;\n            function updateLastSeparatorLabel() {\n                if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n                    lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n                }\n            }\n            for (const symbolPick of sortedFilteredSymbolPicks) {\n                // Found new kind\n                if (lastSymbolKind !== symbolPick.kind) {\n                    // Update last separator with number of symbols we found for kind\n                    updateLastSeparatorLabel();\n                    lastSymbolKind = symbolPick.kind;\n                    lastSymbolKindCounter = 1;\n                    // Add new separator for new kind\n                    lastSeparator = { type: 'separator' };\n                    symbolPicks.push(lastSeparator);\n                }\n                // Existing kind, keep counting\n                else {\n                    lastSymbolKindCounter++;\n                }\n                // Add to final result\n                symbolPicks.push(symbolPick);\n            }\n            // Update last separator with number of symbols we found for kind\n            updateLastSeparatorLabel();\n        }\n        else if (sortedFilteredSymbolPicks.length > 0) {\n            symbolPicks = [\n                { label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length), type: 'separator' },\n                ...sortedFilteredSymbolPicks\n            ];\n        }\n        return symbolPicks;\n    }\n    compareByScore(symbolA, symbolB) {\n        if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n            return 1;\n        }\n        else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n            return -1;\n        }\n        if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n            if (symbolA.score > symbolB.score) {\n                return -1;\n            }\n            else if (symbolA.score < symbolB.score) {\n                return 1;\n            }\n        }\n        if (symbolA.index < symbolB.index) {\n            return -1;\n        }\n        else if (symbolA.index > symbolB.index) {\n            return 1;\n        }\n        return 0;\n    }\n    compareByKindAndScore(symbolA, symbolB) {\n        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n        // Sort by type first if scoped search\n        const result = kindA.localeCompare(kindB);\n        if (result === 0) {\n            return this.compareByScore(symbolA, symbolB);\n        }\n        return result;\n    }\n    async getDocumentSymbols(document, token) {\n        const model = await this._outlineModelService.getOrCreate(document, token);\n        return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n    }\n};\nAbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = __decorate([\n    __param(0, ILanguageFeaturesService),\n    __param(1, IOutlineModelService)\n], AbstractGotoSymbolQuickAccessProvider);\nexport { AbstractGotoSymbolQuickAccessProvider };\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n    [5 /* SymbolKind.Method */]: localize('method', \"methods ({0})\"),\n    [11 /* SymbolKind.Function */]: localize('function', \"functions ({0})\"),\n    [8 /* SymbolKind.Constructor */]: localize('_constructor', \"constructors ({0})\"),\n    [12 /* SymbolKind.Variable */]: localize('variable', \"variables ({0})\"),\n    [4 /* SymbolKind.Class */]: localize('class', \"classes ({0})\"),\n    [22 /* SymbolKind.Struct */]: localize('struct', \"structs ({0})\"),\n    [23 /* SymbolKind.Event */]: localize('event', \"events ({0})\"),\n    [24 /* SymbolKind.Operator */]: localize('operator', \"operators ({0})\"),\n    [10 /* SymbolKind.Interface */]: localize('interface', \"interfaces ({0})\"),\n    [2 /* SymbolKind.Namespace */]: localize('namespace', \"namespaces ({0})\"),\n    [3 /* SymbolKind.Package */]: localize('package', \"packages ({0})\"),\n    [25 /* SymbolKind.TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n    [1 /* SymbolKind.Module */]: localize('modules', \"modules ({0})\"),\n    [6 /* SymbolKind.Property */]: localize('property', \"properties ({0})\"),\n    [9 /* SymbolKind.Enum */]: localize('enum', \"enumerations ({0})\"),\n    [21 /* SymbolKind.EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n    [14 /* SymbolKind.String */]: localize('string', \"strings ({0})\"),\n    [0 /* SymbolKind.File */]: localize('file', \"files ({0})\"),\n    [17 /* SymbolKind.Array */]: localize('array', \"arrays ({0})\"),\n    [15 /* SymbolKind.Number */]: localize('number', \"numbers ({0})\"),\n    [16 /* SymbolKind.Boolean */]: localize('boolean', \"booleans ({0})\"),\n    [18 /* SymbolKind.Object */]: localize('object', \"objects ({0})\"),\n    [19 /* SymbolKind.Key */]: localize('key', \"keys ({0})\"),\n    [7 /* SymbolKind.Field */]: localize('field', \"fields ({0})\"),\n    [13 /* SymbolKind.Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}