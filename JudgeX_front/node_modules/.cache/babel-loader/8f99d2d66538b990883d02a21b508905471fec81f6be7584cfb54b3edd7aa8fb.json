{"ast":null,"code":"var _CopyPasteController;\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.flat-map.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar CopyPasteController_1;\nimport { addDisposableListener, getActiveDocument } from '../../../../base/browser/dom.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { createCancelablePromise, DeferredPromise, raceCancellation } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { UriList, createStringDataTransferItem, matchesMimeType } from '../../../../base/common/dataTransfer.js';\nimport { HierarchicalKind } from '../../../../base/common/hierarchicalKind.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../../base/common/mime.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { generateUuid } from '../../../../base/common/uuid.js';\nimport { ClipboardEventUtils } from '../../../browser/controller/textAreaInput.js';\nimport { toExternalVSDataTransfer, toVSDataTransfer } from '../../../browser/dnd.js';\nimport { IBulkEditService } from '../../../browser/services/bulkEditService.js';\nimport { Range } from '../../../common/core/range.js';\nimport { DocumentPasteTriggerKind } from '../../../common/languages.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { DefaultTextPasteOrDropEditProvider } from './defaultProviders.js';\nimport { createCombinedWorkspaceEdit, sortEditsByYieldTo } from './edit.js';\nimport { EditorStateCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { InlineProgressManager } from '../../inlineProgress/browser/inlineProgress.js';\nimport { MessageController } from '../../message/browser/messageController.js';\nimport { localize } from '../../../../nls.js';\nimport { IClipboardService } from '../../../../platform/clipboard/common/clipboardService.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IProgressService } from '../../../../platform/progress/common/progress.js';\nimport { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';\nimport { PostEditWidgetManager } from './postEditWidget.js';\nimport { CancellationError, isCancellationError } from '../../../../base/common/errors.js';\nexport const changePasteTypeCommandId = 'editor.changePasteType';\nexport const pasteWidgetVisibleCtx = new RawContextKey('pasteWidgetVisible', false, localize('pasteWidgetVisible', \"Whether the paste widget is showing\"));\nconst vscodeClipboardMime = 'application/vnd.code.copyMetadata';\nlet CopyPasteController = (_CopyPasteController = class CopyPasteController extends Disposable {\n  static get(editor) {\n    return editor.getContribution(CopyPasteController_1.ID);\n  }\n  constructor(editor, instantiationService, _bulkEditService, _clipboardService, _languageFeaturesService, _quickInputService, _progressService) {\n    super();\n    this._bulkEditService = _bulkEditService;\n    this._clipboardService = _clipboardService;\n    this._languageFeaturesService = _languageFeaturesService;\n    this._quickInputService = _quickInputService;\n    this._progressService = _progressService;\n    this._editor = editor;\n    const container = editor.getContainerDomNode();\n    this._register(addDisposableListener(container, 'copy', e => this.handleCopy(e)));\n    this._register(addDisposableListener(container, 'cut', e => this.handleCopy(e)));\n    this._register(addDisposableListener(container, 'paste', e => this.handlePaste(e), true));\n    this._pasteProgressManager = this._register(new InlineProgressManager('pasteIntoEditor', editor, instantiationService));\n    this._postPasteWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, 'pasteIntoEditor', editor, pasteWidgetVisibleCtx, {\n      id: changePasteTypeCommandId,\n      label: localize('postPasteWidgetTitle', \"Show paste options...\")\n    }));\n  }\n  changePasteType() {\n    this._postPasteWidgetManager.tryShowSelector();\n  }\n  pasteAs(preferred) {\n    this._editor.focus();\n    try {\n      this._pasteAsActionContext = {\n        preferred\n      };\n      getActiveDocument().execCommand('paste');\n    } finally {\n      this._pasteAsActionContext = undefined;\n    }\n  }\n  clearWidgets() {\n    this._postPasteWidgetManager.clear();\n  }\n  isPasteAsEnabled() {\n    return this._editor.getOption(85 /* EditorOption.pasteAs */).enabled;\n  }\n  async finishedPaste() {\n    await this._currentPasteOperation;\n  }\n  handleCopy(e) {\n    if (!this._editor.hasTextFocus()) {\n      return;\n    }\n    // Explicitly clear the clipboard internal state.\n    // This is needed because on web, the browser clipboard is faked out using an in-memory store.\n    // This means the resources clipboard is not properly updated when copying from the editor.\n    this._clipboardService.clearInternalState?.();\n    if (!e.clipboardData || !this.isPasteAsEnabled()) {\n      return;\n    }\n    const model = this._editor.getModel();\n    const selections = this._editor.getSelections();\n    if (!model || !selections?.length) {\n      return;\n    }\n    const enableEmptySelectionClipboard = this._editor.getOption(37 /* EditorOption.emptySelectionClipboard */);\n    let ranges = selections;\n    const wasFromEmptySelection = selections.length === 1 && selections[0].isEmpty();\n    if (wasFromEmptySelection) {\n      if (!enableEmptySelectionClipboard) {\n        return;\n      }\n      ranges = [new Range(ranges[0].startLineNumber, 1, ranges[0].startLineNumber, 1 + model.getLineLength(ranges[0].startLineNumber))];\n    }\n    const toCopy = this._editor._getViewModel()?.getPlainTextToCopy(selections, enableEmptySelectionClipboard, platform.isWindows);\n    const multicursorText = Array.isArray(toCopy) ? toCopy : null;\n    const defaultPastePayload = {\n      multicursorText,\n      pasteOnNewLine: wasFromEmptySelection,\n      mode: null\n    };\n    const providers = this._languageFeaturesService.documentPasteEditProvider.ordered(model).filter(x => !!x.prepareDocumentPaste);\n    if (!providers.length) {\n      this.setCopyMetadata(e.clipboardData, {\n        defaultPastePayload\n      });\n      return;\n    }\n    const dataTransfer = toVSDataTransfer(e.clipboardData);\n    const providerCopyMimeTypes = providers.flatMap(x => x.copyMimeTypes ?? []);\n    // Save off a handle pointing to data that VS Code maintains.\n    const handle = generateUuid();\n    this.setCopyMetadata(e.clipboardData, {\n      id: handle,\n      providerCopyMimeTypes,\n      defaultPastePayload\n    });\n    const promise = createCancelablePromise(async token => {\n      const results = coalesce(await Promise.all(providers.map(async provider => {\n        try {\n          return await provider.prepareDocumentPaste(model, ranges, dataTransfer, token);\n        } catch (err) {\n          console.error(err);\n          return undefined;\n        }\n      })));\n      // Values from higher priority providers should overwrite values from lower priority ones.\n      // Reverse the array to so that the calls to `replace` below will do this\n      results.reverse();\n      for (const result of results) {\n        for (const [mime, value] of result) {\n          dataTransfer.replace(mime, value);\n        }\n      }\n      return dataTransfer;\n    });\n    CopyPasteController_1._currentCopyOperation?.dataTransferPromise.cancel();\n    CopyPasteController_1._currentCopyOperation = {\n      handle: handle,\n      dataTransferPromise: promise\n    };\n  }\n  async handlePaste(e) {\n    if (!e.clipboardData || !this._editor.hasTextFocus()) {\n      return;\n    }\n    MessageController.get(this._editor)?.closeMessage();\n    this._currentPasteOperation?.cancel();\n    this._currentPasteOperation = undefined;\n    const model = this._editor.getModel();\n    const selections = this._editor.getSelections();\n    if (!selections?.length || !model) {\n      return;\n    }\n    if (this._editor.getOption(92 /* EditorOption.readOnly */) // Never enabled if editor is readonly.\n    || !this.isPasteAsEnabled() && !this._pasteAsActionContext // Or feature disabled (but still enable if paste was explicitly requested)\n    ) {\n      return;\n    }\n    const metadata = this.fetchCopyMetadata(e);\n    const dataTransfer = toExternalVSDataTransfer(e.clipboardData);\n    dataTransfer.delete(vscodeClipboardMime);\n    const allPotentialMimeTypes = [...e.clipboardData.types, ...(metadata?.providerCopyMimeTypes ?? []),\n    // TODO: always adds `uri-list` because this get set if there are resources in the system clipboard.\n    // However we can only check the system clipboard async. For this early check, just add it in.\n    // We filter providers again once we have the final dataTransfer we will use.\n    Mimes.uriList];\n    const allProviders = this._languageFeaturesService.documentPasteEditProvider.ordered(model).filter(provider => {\n      // Filter out providers that don't match the requested paste types\n      const preference = this._pasteAsActionContext?.preferred;\n      if (preference) {\n        if (provider.providedPasteEditKinds && !this.providerMatchesPreference(provider, preference)) {\n          return false;\n        }\n      }\n      // And providers that don't handle any of mime types in the clipboard\n      return provider.pasteMimeTypes?.some(type => matchesMimeType(type, allPotentialMimeTypes));\n    });\n    if (!allProviders.length) {\n      if (this._pasteAsActionContext?.preferred) {\n        this.showPasteAsNoEditMessage(selections, this._pasteAsActionContext.preferred);\n      }\n      return;\n    }\n    // Prevent the editor's default paste handler from running.\n    // Note that after this point, we are fully responsible for handling paste.\n    // If we can't provider a paste for any reason, we need to explicitly delegate pasting back to the editor.\n    e.preventDefault();\n    e.stopImmediatePropagation();\n    if (this._pasteAsActionContext) {\n      this.showPasteAsPick(this._pasteAsActionContext.preferred, allProviders, selections, dataTransfer, metadata);\n    } else {\n      this.doPasteInline(allProviders, selections, dataTransfer, metadata, e);\n    }\n  }\n  showPasteAsNoEditMessage(selections, preference) {\n    MessageController.get(this._editor)?.showMessage(localize('pasteAsError', \"No paste edits for '{0}' found\", preference instanceof HierarchicalKind ? preference.value : preference.providerId), selections[0].getStartPosition());\n  }\n  doPasteInline(allProviders, selections, dataTransfer, metadata, clipboardEvent) {\n    const editor = this._editor;\n    if (!editor.hasModel()) {\n      return;\n    }\n    const editorStateCts = new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */, undefined);\n    const p = createCancelablePromise(async pToken => {\n      const editor = this._editor;\n      if (!editor.hasModel()) {\n        return;\n      }\n      const model = editor.getModel();\n      const disposables = new DisposableStore();\n      const cts = disposables.add(new CancellationTokenSource(pToken));\n      disposables.add(editorStateCts.token.onCancellationRequested(() => cts.cancel()));\n      const token = cts.token;\n      try {\n        await this.mergeInDataFromCopy(dataTransfer, metadata, token);\n        if (token.isCancellationRequested) {\n          return;\n        }\n        const supportedProviders = allProviders.filter(provider => this.isSupportedPasteProvider(provider, dataTransfer));\n        if (!supportedProviders.length || supportedProviders.length === 1 && supportedProviders[0] instanceof DefaultTextPasteOrDropEditProvider // Only our default text provider is active\n        ) {\n          return this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n        }\n        const context = {\n          triggerKind: DocumentPasteTriggerKind.Automatic\n        };\n        const editSession = await this.getPasteEdits(supportedProviders, dataTransfer, model, selections, context, token);\n        disposables.add(editSession);\n        if (token.isCancellationRequested) {\n          return;\n        }\n        // If the only edit returned is our default text edit, use the default paste handler\n        if (editSession.edits.length === 1 && editSession.edits[0].provider instanceof DefaultTextPasteOrDropEditProvider) {\n          return this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n        }\n        if (editSession.edits.length) {\n          const canShowWidget = editor.getOption(85 /* EditorOption.pasteAs */).showPasteSelector === 'afterPaste';\n          return this._postPasteWidgetManager.applyEditAndShowIfNeeded(selections, {\n            activeEditIndex: 0,\n            allEdits: editSession.edits\n          }, canShowWidget, (edit, token) => {\n            return new Promise((resolve, reject) => {\n              (async () => {\n                try {\n                  const resolveP = edit.provider.resolveDocumentPasteEdit?.(edit, token);\n                  const showP = new DeferredPromise();\n                  const resolved = resolveP && (await this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize('resolveProcess', \"Resolving paste edit. Click to cancel\"), Promise.race([showP.p, resolveP]), {\n                    cancel: () => {\n                      showP.cancel();\n                      return reject(new CancellationError());\n                    }\n                  }, 0));\n                  if (resolved) {\n                    edit.additionalEdit = resolved.additionalEdit;\n                  }\n                  return resolve(edit);\n                } catch (err) {\n                  return reject(err);\n                }\n              })();\n            });\n          }, token);\n        }\n        await this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n      } finally {\n        disposables.dispose();\n        if (this._currentPasteOperation === p) {\n          this._currentPasteOperation = undefined;\n        }\n      }\n    });\n    this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize('pasteIntoEditorProgress', \"Running paste handlers. Click to cancel and do basic paste\"), p, {\n      cancel: async () => {\n        try {\n          p.cancel();\n          if (editorStateCts.token.isCancellationRequested) {\n            return;\n          }\n          await this.applyDefaultPasteHandler(dataTransfer, metadata, editorStateCts.token, clipboardEvent);\n        } finally {\n          editorStateCts.dispose();\n        }\n      }\n    }).then(() => {\n      editorStateCts.dispose();\n    });\n    this._currentPasteOperation = p;\n  }\n  showPasteAsPick(preference, allProviders, selections, dataTransfer, metadata) {\n    const p = createCancelablePromise(async token => {\n      const editor = this._editor;\n      if (!editor.hasModel()) {\n        return;\n      }\n      const model = editor.getModel();\n      const disposables = new DisposableStore();\n      const tokenSource = disposables.add(new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */, undefined, token));\n      try {\n        await this.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);\n        if (tokenSource.token.isCancellationRequested) {\n          return;\n        }\n        // Filter out any providers the don't match the full data transfer we will send them.\n        let supportedProviders = allProviders.filter(provider => this.isSupportedPasteProvider(provider, dataTransfer, preference));\n        if (preference) {\n          // We are looking for a specific edit\n          supportedProviders = supportedProviders.filter(provider => this.providerMatchesPreference(provider, preference));\n        }\n        const context = {\n          triggerKind: DocumentPasteTriggerKind.PasteAs,\n          only: preference && preference instanceof HierarchicalKind ? preference : undefined\n        };\n        let editSession = disposables.add(await this.getPasteEdits(supportedProviders, dataTransfer, model, selections, context, tokenSource.token));\n        if (tokenSource.token.isCancellationRequested) {\n          return;\n        }\n        // Filter out any edits that don't match the requested kind\n        if (preference) {\n          editSession = {\n            edits: editSession.edits.filter(edit => {\n              if (preference instanceof HierarchicalKind) {\n                return preference.contains(edit.kind);\n              } else {\n                return preference.providerId === edit.provider.id;\n              }\n            }),\n            dispose: editSession.dispose\n          };\n        }\n        if (!editSession.edits.length) {\n          if (context.only) {\n            this.showPasteAsNoEditMessage(selections, context.only);\n          }\n          return;\n        }\n        let pickedEdit;\n        if (preference) {\n          pickedEdit = editSession.edits.at(0);\n        } else {\n          const selected = await this._quickInputService.pick(editSession.edits.map(edit => ({\n            label: edit.title,\n            description: edit.kind?.value,\n            edit\n          })), {\n            placeHolder: localize('pasteAsPickerPlaceholder', \"Select Paste Action\")\n          });\n          pickedEdit = selected?.edit;\n        }\n        if (!pickedEdit) {\n          return;\n        }\n        const combinedWorkspaceEdit = createCombinedWorkspaceEdit(model.uri, selections, pickedEdit);\n        await this._bulkEditService.apply(combinedWorkspaceEdit, {\n          editor: this._editor\n        });\n      } finally {\n        disposables.dispose();\n        if (this._currentPasteOperation === p) {\n          this._currentPasteOperation = undefined;\n        }\n      }\n    });\n    this._progressService.withProgress({\n      location: 10 /* ProgressLocation.Window */,\n      title: localize('pasteAsProgress', \"Running paste handlers\")\n    }, () => p);\n  }\n  setCopyMetadata(dataTransfer, metadata) {\n    dataTransfer.setData(vscodeClipboardMime, JSON.stringify(metadata));\n  }\n  fetchCopyMetadata(e) {\n    if (!e.clipboardData) {\n      return;\n    }\n    // Prefer using the clipboard data we saved off\n    const rawMetadata = e.clipboardData.getData(vscodeClipboardMime);\n    if (rawMetadata) {\n      try {\n        return JSON.parse(rawMetadata);\n      } catch {\n        return undefined;\n      }\n    }\n    // Otherwise try to extract the generic text editor metadata\n    const [_, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n    if (metadata) {\n      return {\n        defaultPastePayload: {\n          mode: metadata.mode,\n          multicursorText: metadata.multicursorText ?? null,\n          pasteOnNewLine: !!metadata.isFromEmptySelection\n        }\n      };\n    }\n    return undefined;\n  }\n  async mergeInDataFromCopy(dataTransfer, metadata, token) {\n    if (metadata?.id && CopyPasteController_1._currentCopyOperation?.handle === metadata.id) {\n      const toMergeDataTransfer = await CopyPasteController_1._currentCopyOperation.dataTransferPromise;\n      if (token.isCancellationRequested) {\n        return;\n      }\n      for (const [key, value] of toMergeDataTransfer) {\n        dataTransfer.replace(key, value);\n      }\n    }\n    if (!dataTransfer.has(Mimes.uriList)) {\n      const resources = await this._clipboardService.readResources();\n      if (token.isCancellationRequested) {\n        return;\n      }\n      if (resources.length) {\n        dataTransfer.append(Mimes.uriList, createStringDataTransferItem(UriList.create(resources)));\n      }\n    }\n  }\n  async getPasteEdits(providers, dataTransfer, model, selections, context, token) {\n    const disposables = new DisposableStore();\n    const results = await raceCancellation(Promise.all(providers.map(async provider => {\n      try {\n        const edits = await provider.provideDocumentPasteEdits?.(model, selections, dataTransfer, context, token);\n        if (edits) {\n          disposables.add(edits);\n        }\n        return edits?.edits?.map(edit => ({\n          ...edit,\n          provider\n        }));\n      } catch (err) {\n        if (!isCancellationError(err)) {\n          console.error(err);\n        }\n        return undefined;\n      }\n    })), token);\n    const edits = coalesce(results ?? []).flat().filter(edit => {\n      return !context.only || context.only.contains(edit.kind);\n    });\n    return {\n      edits: sortEditsByYieldTo(edits),\n      dispose: () => disposables.dispose()\n    };\n  }\n  async applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent) {\n    const textDataTransfer = dataTransfer.get(Mimes.text) ?? dataTransfer.get('text');\n    const text = (await textDataTransfer?.asString()) ?? '';\n    if (token.isCancellationRequested) {\n      return;\n    }\n    const payload = {\n      clipboardEvent,\n      text,\n      pasteOnNewLine: metadata?.defaultPastePayload.pasteOnNewLine ?? false,\n      multicursorText: metadata?.defaultPastePayload.multicursorText ?? null,\n      mode: null\n    };\n    this._editor.trigger('keyboard', \"paste\" /* Handler.Paste */, payload);\n  }\n  /**\n   * Filter out providers if they:\n   * - Don't handle any of the data transfer types we have\n   * - Don't match the preferred paste kind\n   */\n  isSupportedPasteProvider(provider, dataTransfer, preference) {\n    if (!provider.pasteMimeTypes?.some(type => dataTransfer.matches(type))) {\n      return false;\n    }\n    return !preference || this.providerMatchesPreference(provider, preference);\n  }\n  providerMatchesPreference(provider, preference) {\n    if (preference instanceof HierarchicalKind) {\n      if (!provider.providedPasteEditKinds) {\n        return true;\n      }\n      return provider.providedPasteEditKinds.some(providedKind => preference.contains(providedKind));\n    } else {\n      return provider.id === preference.providerId;\n    }\n  }\n}, CopyPasteController_1 = _CopyPasteController, _CopyPasteController.ID = 'editor.contrib.copyPasteActionController', _CopyPasteController);\nCopyPasteController = CopyPasteController_1 = __decorate([__param(1, IInstantiationService), __param(2, IBulkEditService), __param(3, IClipboardService), __param(4, ILanguageFeaturesService), __param(5, IQuickInputService), __param(6, IProgressService)], CopyPasteController);\nexport { CopyPasteController };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","CopyPasteController_1","addDisposableListener","getActiveDocument","coalesce","createCancelablePromise","DeferredPromise","raceCancellation","CancellationTokenSource","UriList","createStringDataTransferItem","matchesMimeType","HierarchicalKind","Disposable","DisposableStore","Mimes","platform","generateUuid","ClipboardEventUtils","toExternalVSDataTransfer","toVSDataTransfer","IBulkEditService","Range","DocumentPasteTriggerKind","ILanguageFeaturesService","DefaultTextPasteOrDropEditProvider","createCombinedWorkspaceEdit","sortEditsByYieldTo","EditorStateCancellationTokenSource","InlineProgressManager","MessageController","localize","IClipboardService","RawContextKey","IInstantiationService","IProgressService","IQuickInputService","PostEditWidgetManager","CancellationError","isCancellationError","changePasteTypeCommandId","pasteWidgetVisibleCtx","vscodeClipboardMime","CopyPasteController","_CopyPasteController","get","editor","getContribution","ID","constructor","instantiationService","_bulkEditService","_clipboardService","_languageFeaturesService","_quickInputService","_progressService","_editor","container","getContainerDomNode","_register","e","handleCopy","handlePaste","_pasteProgressManager","_postPasteWidgetManager","createInstance","id","label","changePasteType","tryShowSelector","pasteAs","preferred","focus","_pasteAsActionContext","execCommand","undefined","clearWidgets","clear","isPasteAsEnabled","getOption","enabled","finishedPaste","_currentPasteOperation","hasTextFocus","clearInternalState","clipboardData","model","getModel","selections","getSelections","enableEmptySelectionClipboard","ranges","wasFromEmptySelection","isEmpty","startLineNumber","getLineLength","toCopy","_getViewModel","getPlainTextToCopy","isWindows","multicursorText","Array","isArray","defaultPastePayload","pasteOnNewLine","mode","providers","documentPasteEditProvider","ordered","filter","x","prepareDocumentPaste","setCopyMetadata","dataTransfer","providerCopyMimeTypes","flatMap","copyMimeTypes","handle","promise","token","results","Promise","all","map","provider","err","console","error","reverse","result","mime","value","replace","_currentCopyOperation","dataTransferPromise","cancel","closeMessage","metadata","fetchCopyMetadata","delete","allPotentialMimeTypes","types","uriList","allProviders","preference","providedPasteEditKinds","providerMatchesPreference","pasteMimeTypes","some","type","showPasteAsNoEditMessage","preventDefault","stopImmediatePropagation","showPasteAsPick","doPasteInline","showMessage","providerId","getStartPosition","clipboardEvent","hasModel","editorStateCts","p","pToken","disposables","cts","add","onCancellationRequested","mergeInDataFromCopy","isCancellationRequested","supportedProviders","isSupportedPasteProvider","applyDefaultPasteHandler","context","triggerKind","Automatic","editSession","getPasteEdits","edits","canShowWidget","showPasteSelector","applyEditAndShowIfNeeded","activeEditIndex","allEdits","edit","resolve","reject","resolveP","resolveDocumentPasteEdit","showP","resolved","showWhile","getEndPosition","race","additionalEdit","dispose","then","tokenSource","PasteAs","only","contains","kind","pickedEdit","at","selected","pick","title","description","placeHolder","combinedWorkspaceEdit","uri","apply","withProgress","location","setData","JSON","stringify","rawMetadata","getData","parse","_","getTextData","isFromEmptySelection","toMergeDataTransfer","has","resources","readResources","append","create","provideDocumentPasteEdits","flat","textDataTransfer","text","asString","payload","trigger","matches","providedKind"],"sources":["P:/IDEA/JudgeX/JudgeX_front/node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar CopyPasteController_1;\nimport { addDisposableListener, getActiveDocument } from '../../../../base/browser/dom.js';\nimport { coalesce } from '../../../../base/common/arrays.js';\nimport { createCancelablePromise, DeferredPromise, raceCancellation } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { UriList, createStringDataTransferItem, matchesMimeType } from '../../../../base/common/dataTransfer.js';\nimport { HierarchicalKind } from '../../../../base/common/hierarchicalKind.js';\nimport { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../../base/common/mime.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { generateUuid } from '../../../../base/common/uuid.js';\nimport { ClipboardEventUtils } from '../../../browser/controller/textAreaInput.js';\nimport { toExternalVSDataTransfer, toVSDataTransfer } from '../../../browser/dnd.js';\nimport { IBulkEditService } from '../../../browser/services/bulkEditService.js';\nimport { Range } from '../../../common/core/range.js';\nimport { DocumentPasteTriggerKind } from '../../../common/languages.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { DefaultTextPasteOrDropEditProvider } from './defaultProviders.js';\nimport { createCombinedWorkspaceEdit, sortEditsByYieldTo } from './edit.js';\nimport { EditorStateCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { InlineProgressManager } from '../../inlineProgress/browser/inlineProgress.js';\nimport { MessageController } from '../../message/browser/messageController.js';\nimport { localize } from '../../../../nls.js';\nimport { IClipboardService } from '../../../../platform/clipboard/common/clipboardService.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IProgressService } from '../../../../platform/progress/common/progress.js';\nimport { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.js';\nimport { PostEditWidgetManager } from './postEditWidget.js';\nimport { CancellationError, isCancellationError } from '../../../../base/common/errors.js';\nexport const changePasteTypeCommandId = 'editor.changePasteType';\nexport const pasteWidgetVisibleCtx = new RawContextKey('pasteWidgetVisible', false, localize('pasteWidgetVisible', \"Whether the paste widget is showing\"));\nconst vscodeClipboardMime = 'application/vnd.code.copyMetadata';\nlet CopyPasteController = class CopyPasteController extends Disposable {\n    static { CopyPasteController_1 = this; }\n    static { this.ID = 'editor.contrib.copyPasteActionController'; }\n    static get(editor) {\n        return editor.getContribution(CopyPasteController_1.ID);\n    }\n    constructor(editor, instantiationService, _bulkEditService, _clipboardService, _languageFeaturesService, _quickInputService, _progressService) {\n        super();\n        this._bulkEditService = _bulkEditService;\n        this._clipboardService = _clipboardService;\n        this._languageFeaturesService = _languageFeaturesService;\n        this._quickInputService = _quickInputService;\n        this._progressService = _progressService;\n        this._editor = editor;\n        const container = editor.getContainerDomNode();\n        this._register(addDisposableListener(container, 'copy', e => this.handleCopy(e)));\n        this._register(addDisposableListener(container, 'cut', e => this.handleCopy(e)));\n        this._register(addDisposableListener(container, 'paste', e => this.handlePaste(e), true));\n        this._pasteProgressManager = this._register(new InlineProgressManager('pasteIntoEditor', editor, instantiationService));\n        this._postPasteWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, 'pasteIntoEditor', editor, pasteWidgetVisibleCtx, { id: changePasteTypeCommandId, label: localize('postPasteWidgetTitle', \"Show paste options...\") }));\n    }\n    changePasteType() {\n        this._postPasteWidgetManager.tryShowSelector();\n    }\n    pasteAs(preferred) {\n        this._editor.focus();\n        try {\n            this._pasteAsActionContext = { preferred };\n            getActiveDocument().execCommand('paste');\n        }\n        finally {\n            this._pasteAsActionContext = undefined;\n        }\n    }\n    clearWidgets() {\n        this._postPasteWidgetManager.clear();\n    }\n    isPasteAsEnabled() {\n        return this._editor.getOption(85 /* EditorOption.pasteAs */).enabled;\n    }\n    async finishedPaste() {\n        await this._currentPasteOperation;\n    }\n    handleCopy(e) {\n        if (!this._editor.hasTextFocus()) {\n            return;\n        }\n        // Explicitly clear the clipboard internal state.\n        // This is needed because on web, the browser clipboard is faked out using an in-memory store.\n        // This means the resources clipboard is not properly updated when copying from the editor.\n        this._clipboardService.clearInternalState?.();\n        if (!e.clipboardData || !this.isPasteAsEnabled()) {\n            return;\n        }\n        const model = this._editor.getModel();\n        const selections = this._editor.getSelections();\n        if (!model || !selections?.length) {\n            return;\n        }\n        const enableEmptySelectionClipboard = this._editor.getOption(37 /* EditorOption.emptySelectionClipboard */);\n        let ranges = selections;\n        const wasFromEmptySelection = selections.length === 1 && selections[0].isEmpty();\n        if (wasFromEmptySelection) {\n            if (!enableEmptySelectionClipboard) {\n                return;\n            }\n            ranges = [new Range(ranges[0].startLineNumber, 1, ranges[0].startLineNumber, 1 + model.getLineLength(ranges[0].startLineNumber))];\n        }\n        const toCopy = this._editor._getViewModel()?.getPlainTextToCopy(selections, enableEmptySelectionClipboard, platform.isWindows);\n        const multicursorText = Array.isArray(toCopy) ? toCopy : null;\n        const defaultPastePayload = {\n            multicursorText,\n            pasteOnNewLine: wasFromEmptySelection,\n            mode: null\n        };\n        const providers = this._languageFeaturesService.documentPasteEditProvider\n            .ordered(model)\n            .filter(x => !!x.prepareDocumentPaste);\n        if (!providers.length) {\n            this.setCopyMetadata(e.clipboardData, { defaultPastePayload });\n            return;\n        }\n        const dataTransfer = toVSDataTransfer(e.clipboardData);\n        const providerCopyMimeTypes = providers.flatMap(x => x.copyMimeTypes ?? []);\n        // Save off a handle pointing to data that VS Code maintains.\n        const handle = generateUuid();\n        this.setCopyMetadata(e.clipboardData, {\n            id: handle,\n            providerCopyMimeTypes,\n            defaultPastePayload\n        });\n        const promise = createCancelablePromise(async (token) => {\n            const results = coalesce(await Promise.all(providers.map(async (provider) => {\n                try {\n                    return await provider.prepareDocumentPaste(model, ranges, dataTransfer, token);\n                }\n                catch (err) {\n                    console.error(err);\n                    return undefined;\n                }\n            })));\n            // Values from higher priority providers should overwrite values from lower priority ones.\n            // Reverse the array to so that the calls to `replace` below will do this\n            results.reverse();\n            for (const result of results) {\n                for (const [mime, value] of result) {\n                    dataTransfer.replace(mime, value);\n                }\n            }\n            return dataTransfer;\n        });\n        CopyPasteController_1._currentCopyOperation?.dataTransferPromise.cancel();\n        CopyPasteController_1._currentCopyOperation = { handle: handle, dataTransferPromise: promise };\n    }\n    async handlePaste(e) {\n        if (!e.clipboardData || !this._editor.hasTextFocus()) {\n            return;\n        }\n        MessageController.get(this._editor)?.closeMessage();\n        this._currentPasteOperation?.cancel();\n        this._currentPasteOperation = undefined;\n        const model = this._editor.getModel();\n        const selections = this._editor.getSelections();\n        if (!selections?.length || !model) {\n            return;\n        }\n        if (this._editor.getOption(92 /* EditorOption.readOnly */) // Never enabled if editor is readonly.\n            || (!this.isPasteAsEnabled() && !this._pasteAsActionContext) // Or feature disabled (but still enable if paste was explicitly requested)\n        ) {\n            return;\n        }\n        const metadata = this.fetchCopyMetadata(e);\n        const dataTransfer = toExternalVSDataTransfer(e.clipboardData);\n        dataTransfer.delete(vscodeClipboardMime);\n        const allPotentialMimeTypes = [\n            ...e.clipboardData.types,\n            ...metadata?.providerCopyMimeTypes ?? [],\n            // TODO: always adds `uri-list` because this get set if there are resources in the system clipboard.\n            // However we can only check the system clipboard async. For this early check, just add it in.\n            // We filter providers again once we have the final dataTransfer we will use.\n            Mimes.uriList,\n        ];\n        const allProviders = this._languageFeaturesService.documentPasteEditProvider\n            .ordered(model)\n            .filter(provider => {\n            // Filter out providers that don't match the requested paste types\n            const preference = this._pasteAsActionContext?.preferred;\n            if (preference) {\n                if (provider.providedPasteEditKinds && !this.providerMatchesPreference(provider, preference)) {\n                    return false;\n                }\n            }\n            // And providers that don't handle any of mime types in the clipboard\n            return provider.pasteMimeTypes?.some(type => matchesMimeType(type, allPotentialMimeTypes));\n        });\n        if (!allProviders.length) {\n            if (this._pasteAsActionContext?.preferred) {\n                this.showPasteAsNoEditMessage(selections, this._pasteAsActionContext.preferred);\n            }\n            return;\n        }\n        // Prevent the editor's default paste handler from running.\n        // Note that after this point, we are fully responsible for handling paste.\n        // If we can't provider a paste for any reason, we need to explicitly delegate pasting back to the editor.\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        if (this._pasteAsActionContext) {\n            this.showPasteAsPick(this._pasteAsActionContext.preferred, allProviders, selections, dataTransfer, metadata);\n        }\n        else {\n            this.doPasteInline(allProviders, selections, dataTransfer, metadata, e);\n        }\n    }\n    showPasteAsNoEditMessage(selections, preference) {\n        MessageController.get(this._editor)?.showMessage(localize('pasteAsError', \"No paste edits for '{0}' found\", preference instanceof HierarchicalKind ? preference.value : preference.providerId), selections[0].getStartPosition());\n    }\n    doPasteInline(allProviders, selections, dataTransfer, metadata, clipboardEvent) {\n        const editor = this._editor;\n        if (!editor.hasModel()) {\n            return;\n        }\n        const editorStateCts = new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */, undefined);\n        const p = createCancelablePromise(async (pToken) => {\n            const editor = this._editor;\n            if (!editor.hasModel()) {\n                return;\n            }\n            const model = editor.getModel();\n            const disposables = new DisposableStore();\n            const cts = disposables.add(new CancellationTokenSource(pToken));\n            disposables.add(editorStateCts.token.onCancellationRequested(() => cts.cancel()));\n            const token = cts.token;\n            try {\n                await this.mergeInDataFromCopy(dataTransfer, metadata, token);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                const supportedProviders = allProviders.filter(provider => this.isSupportedPasteProvider(provider, dataTransfer));\n                if (!supportedProviders.length\n                    || (supportedProviders.length === 1 && supportedProviders[0] instanceof DefaultTextPasteOrDropEditProvider) // Only our default text provider is active\n                ) {\n                    return this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n                }\n                const context = {\n                    triggerKind: DocumentPasteTriggerKind.Automatic,\n                };\n                const editSession = await this.getPasteEdits(supportedProviders, dataTransfer, model, selections, context, token);\n                disposables.add(editSession);\n                if (token.isCancellationRequested) {\n                    return;\n                }\n                // If the only edit returned is our default text edit, use the default paste handler\n                if (editSession.edits.length === 1 && editSession.edits[0].provider instanceof DefaultTextPasteOrDropEditProvider) {\n                    return this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n                }\n                if (editSession.edits.length) {\n                    const canShowWidget = editor.getOption(85 /* EditorOption.pasteAs */).showPasteSelector === 'afterPaste';\n                    return this._postPasteWidgetManager.applyEditAndShowIfNeeded(selections, { activeEditIndex: 0, allEdits: editSession.edits }, canShowWidget, (edit, token) => {\n                        return new Promise((resolve, reject) => {\n                            (async () => {\n                                try {\n                                    const resolveP = edit.provider.resolveDocumentPasteEdit?.(edit, token);\n                                    const showP = new DeferredPromise();\n                                    const resolved = resolveP && await this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize('resolveProcess', \"Resolving paste edit. Click to cancel\"), Promise.race([showP.p, resolveP]), {\n                                        cancel: () => {\n                                            showP.cancel();\n                                            return reject(new CancellationError());\n                                        }\n                                    }, 0);\n                                    if (resolved) {\n                                        edit.additionalEdit = resolved.additionalEdit;\n                                    }\n                                    return resolve(edit);\n                                }\n                                catch (err) {\n                                    return reject(err);\n                                }\n                            })();\n                        });\n                    }, token);\n                }\n                await this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);\n            }\n            finally {\n                disposables.dispose();\n                if (this._currentPasteOperation === p) {\n                    this._currentPasteOperation = undefined;\n                }\n            }\n        });\n        this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize('pasteIntoEditorProgress', \"Running paste handlers. Click to cancel and do basic paste\"), p, {\n            cancel: async () => {\n                try {\n                    p.cancel();\n                    if (editorStateCts.token.isCancellationRequested) {\n                        return;\n                    }\n                    await this.applyDefaultPasteHandler(dataTransfer, metadata, editorStateCts.token, clipboardEvent);\n                }\n                finally {\n                    editorStateCts.dispose();\n                }\n            }\n        }).then(() => {\n            editorStateCts.dispose();\n        });\n        this._currentPasteOperation = p;\n    }\n    showPasteAsPick(preference, allProviders, selections, dataTransfer, metadata) {\n        const p = createCancelablePromise(async (token) => {\n            const editor = this._editor;\n            if (!editor.hasModel()) {\n                return;\n            }\n            const model = editor.getModel();\n            const disposables = new DisposableStore();\n            const tokenSource = disposables.add(new EditorStateCancellationTokenSource(editor, 1 /* CodeEditorStateFlag.Value */ | 2 /* CodeEditorStateFlag.Selection */, undefined, token));\n            try {\n                await this.mergeInDataFromCopy(dataTransfer, metadata, tokenSource.token);\n                if (tokenSource.token.isCancellationRequested) {\n                    return;\n                }\n                // Filter out any providers the don't match the full data transfer we will send them.\n                let supportedProviders = allProviders.filter(provider => this.isSupportedPasteProvider(provider, dataTransfer, preference));\n                if (preference) {\n                    // We are looking for a specific edit\n                    supportedProviders = supportedProviders.filter(provider => this.providerMatchesPreference(provider, preference));\n                }\n                const context = {\n                    triggerKind: DocumentPasteTriggerKind.PasteAs,\n                    only: preference && preference instanceof HierarchicalKind ? preference : undefined,\n                };\n                let editSession = disposables.add(await this.getPasteEdits(supportedProviders, dataTransfer, model, selections, context, tokenSource.token));\n                if (tokenSource.token.isCancellationRequested) {\n                    return;\n                }\n                // Filter out any edits that don't match the requested kind\n                if (preference) {\n                    editSession = {\n                        edits: editSession.edits.filter(edit => {\n                            if (preference instanceof HierarchicalKind) {\n                                return preference.contains(edit.kind);\n                            }\n                            else {\n                                return preference.providerId === edit.provider.id;\n                            }\n                        }),\n                        dispose: editSession.dispose\n                    };\n                }\n                if (!editSession.edits.length) {\n                    if (context.only) {\n                        this.showPasteAsNoEditMessage(selections, context.only);\n                    }\n                    return;\n                }\n                let pickedEdit;\n                if (preference) {\n                    pickedEdit = editSession.edits.at(0);\n                }\n                else {\n                    const selected = await this._quickInputService.pick(editSession.edits.map((edit) => ({\n                        label: edit.title,\n                        description: edit.kind?.value,\n                        edit,\n                    })), {\n                        placeHolder: localize('pasteAsPickerPlaceholder', \"Select Paste Action\"),\n                    });\n                    pickedEdit = selected?.edit;\n                }\n                if (!pickedEdit) {\n                    return;\n                }\n                const combinedWorkspaceEdit = createCombinedWorkspaceEdit(model.uri, selections, pickedEdit);\n                await this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor });\n            }\n            finally {\n                disposables.dispose();\n                if (this._currentPasteOperation === p) {\n                    this._currentPasteOperation = undefined;\n                }\n            }\n        });\n        this._progressService.withProgress({\n            location: 10 /* ProgressLocation.Window */,\n            title: localize('pasteAsProgress', \"Running paste handlers\"),\n        }, () => p);\n    }\n    setCopyMetadata(dataTransfer, metadata) {\n        dataTransfer.setData(vscodeClipboardMime, JSON.stringify(metadata));\n    }\n    fetchCopyMetadata(e) {\n        if (!e.clipboardData) {\n            return;\n        }\n        // Prefer using the clipboard data we saved off\n        const rawMetadata = e.clipboardData.getData(vscodeClipboardMime);\n        if (rawMetadata) {\n            try {\n                return JSON.parse(rawMetadata);\n            }\n            catch {\n                return undefined;\n            }\n        }\n        // Otherwise try to extract the generic text editor metadata\n        const [_, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n        if (metadata) {\n            return {\n                defaultPastePayload: {\n                    mode: metadata.mode,\n                    multicursorText: metadata.multicursorText ?? null,\n                    pasteOnNewLine: !!metadata.isFromEmptySelection,\n                },\n            };\n        }\n        return undefined;\n    }\n    async mergeInDataFromCopy(dataTransfer, metadata, token) {\n        if (metadata?.id && CopyPasteController_1._currentCopyOperation?.handle === metadata.id) {\n            const toMergeDataTransfer = await CopyPasteController_1._currentCopyOperation.dataTransferPromise;\n            if (token.isCancellationRequested) {\n                return;\n            }\n            for (const [key, value] of toMergeDataTransfer) {\n                dataTransfer.replace(key, value);\n            }\n        }\n        if (!dataTransfer.has(Mimes.uriList)) {\n            const resources = await this._clipboardService.readResources();\n            if (token.isCancellationRequested) {\n                return;\n            }\n            if (resources.length) {\n                dataTransfer.append(Mimes.uriList, createStringDataTransferItem(UriList.create(resources)));\n            }\n        }\n    }\n    async getPasteEdits(providers, dataTransfer, model, selections, context, token) {\n        const disposables = new DisposableStore();\n        const results = await raceCancellation(Promise.all(providers.map(async (provider) => {\n            try {\n                const edits = await provider.provideDocumentPasteEdits?.(model, selections, dataTransfer, context, token);\n                if (edits) {\n                    disposables.add(edits);\n                }\n                return edits?.edits?.map(edit => ({ ...edit, provider }));\n            }\n            catch (err) {\n                if (!isCancellationError(err)) {\n                    console.error(err);\n                }\n                return undefined;\n            }\n        })), token);\n        const edits = coalesce(results ?? []).flat().filter(edit => {\n            return !context.only || context.only.contains(edit.kind);\n        });\n        return {\n            edits: sortEditsByYieldTo(edits),\n            dispose: () => disposables.dispose()\n        };\n    }\n    async applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent) {\n        const textDataTransfer = dataTransfer.get(Mimes.text) ?? dataTransfer.get('text');\n        const text = (await textDataTransfer?.asString()) ?? '';\n        if (token.isCancellationRequested) {\n            return;\n        }\n        const payload = {\n            clipboardEvent,\n            text,\n            pasteOnNewLine: metadata?.defaultPastePayload.pasteOnNewLine ?? false,\n            multicursorText: metadata?.defaultPastePayload.multicursorText ?? null,\n            mode: null,\n        };\n        this._editor.trigger('keyboard', \"paste\" /* Handler.Paste */, payload);\n    }\n    /**\n     * Filter out providers if they:\n     * - Don't handle any of the data transfer types we have\n     * - Don't match the preferred paste kind\n     */\n    isSupportedPasteProvider(provider, dataTransfer, preference) {\n        if (!provider.pasteMimeTypes?.some(type => dataTransfer.matches(type))) {\n            return false;\n        }\n        return !preference || this.providerMatchesPreference(provider, preference);\n    }\n    providerMatchesPreference(provider, preference) {\n        if (preference instanceof HierarchicalKind) {\n            if (!provider.providedPasteEditKinds) {\n                return true;\n            }\n            return provider.providedPasteEditKinds.some(providedKind => preference.contains(providedKind));\n        }\n        else {\n            return provider.id === preference.providerId;\n        }\n    }\n};\nCopyPasteController = CopyPasteController_1 = __decorate([\n    __param(1, IInstantiationService),\n    __param(2, IBulkEditService),\n    __param(3, IClipboardService),\n    __param(4, ILanguageFeaturesService),\n    __param(5, IQuickInputService),\n    __param(6, IProgressService)\n], CopyPasteController);\nexport { CopyPasteController };\n"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA,IAAIA,UAAU,GAAI,IAAI,IAAI,IAAI,CAACA,UAAU,IAAK,UAAUC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE;EACnF,IAAIC,CAAC,GAAGC,SAAS,CAACC,MAAM;IAAEC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGH,MAAM,GAAGE,IAAI,KAAK,IAAI,GAAGA,IAAI,GAAGK,MAAM,CAACC,wBAAwB,CAACR,MAAM,EAAEC,GAAG,CAAC,GAAGC,IAAI;IAAEO,CAAC;EAC5H,IAAI,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,CAACC,QAAQ,KAAK,UAAU,EAAEL,CAAC,GAAGI,OAAO,CAACC,QAAQ,CAACZ,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,CAAC,CAAC,KAC1H,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAM,GAAG,CAAC,EAAEO,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE,IAAIH,CAAC,GAAGV,UAAU,CAACa,CAAC,CAAC,EAAEN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACH,CAAC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACT,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,GAAGG,CAAC,CAACT,MAAM,EAAEC,GAAG,CAAC,KAAKK,CAAC;EACjJ,OAAOH,CAAC,GAAG,CAAC,IAAIG,CAAC,IAAIC,MAAM,CAACM,cAAc,CAACb,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,EAAEA,CAAC;AACjE,CAAC;AACD,IAAIQ,OAAO,GAAI,IAAI,IAAI,IAAI,CAACA,OAAO,IAAK,UAAUC,UAAU,EAAEC,SAAS,EAAE;EACrE,OAAO,UAAUhB,MAAM,EAAEC,GAAG,EAAE;IAAEe,SAAS,CAAChB,MAAM,EAAEC,GAAG,EAAEc,UAAU,CAAC;EAAE,CAAC;AACzE,CAAC;AACD,IAAIE,qBAAqB;AACzB,SAASC,qBAAqB,EAAEC,iBAAiB,QAAQ,iCAAiC;AAC1F,SAASC,QAAQ,QAAQ,mCAAmC;AAC5D,SAASC,uBAAuB,EAAEC,eAAe,EAAEC,gBAAgB,QAAQ,kCAAkC;AAC7G,SAASC,uBAAuB,QAAQ,yCAAyC;AACjF,SAASC,OAAO,EAAEC,4BAA4B,EAAEC,eAAe,QAAQ,yCAAyC;AAChH,SAASC,gBAAgB,QAAQ,6CAA6C;AAC9E,SAASC,UAAU,EAAEC,eAAe,QAAQ,sCAAsC;AAClF,SAASC,KAAK,QAAQ,iCAAiC;AACvD,OAAO,KAAKC,QAAQ,MAAM,qCAAqC;AAC/D,SAASC,YAAY,QAAQ,iCAAiC;AAC9D,SAASC,mBAAmB,QAAQ,8CAA8C;AAClF,SAASC,wBAAwB,EAAEC,gBAAgB,QAAQ,yBAAyB;AACpF,SAASC,gBAAgB,QAAQ,8CAA8C;AAC/E,SAASC,KAAK,QAAQ,+BAA+B;AACrD,SAASC,wBAAwB,QAAQ,8BAA8B;AACvE,SAASC,wBAAwB,QAAQ,8CAA8C;AACvF,SAASC,kCAAkC,QAAQ,uBAAuB;AAC1E,SAASC,2BAA2B,EAAEC,kBAAkB,QAAQ,WAAW;AAC3E,SAASC,kCAAkC,QAAQ,0CAA0C;AAC7F,SAASC,qBAAqB,QAAQ,gDAAgD;AACtF,SAASC,iBAAiB,QAAQ,4CAA4C;AAC9E,SAASC,QAAQ,QAAQ,oBAAoB;AAC7C,SAASC,iBAAiB,QAAQ,2DAA2D;AAC7F,SAASC,aAAa,QAAQ,sDAAsD;AACpF,SAASC,qBAAqB,QAAQ,4DAA4D;AAClG,SAASC,gBAAgB,QAAQ,kDAAkD;AACnF,SAASC,kBAAkB,QAAQ,sDAAsD;AACzF,SAASC,qBAAqB,QAAQ,qBAAqB;AAC3D,SAASC,iBAAiB,EAAEC,mBAAmB,QAAQ,mCAAmC;AAC1F,OAAO,MAAMC,wBAAwB,GAAG,wBAAwB;AAChE,OAAO,MAAMC,qBAAqB,GAAG,IAAIR,aAAa,CAAC,oBAAoB,EAAE,KAAK,EAAEF,QAAQ,CAAC,oBAAoB,EAAE,qCAAqC,CAAC,CAAC;AAC1J,MAAMW,mBAAmB,GAAG,mCAAmC;AAC/D,IAAIC,mBAAmB,IAAAC,oBAAA,GAAG,MAAMD,mBAAmB,SAAS9B,UAAU,CAAC;EAGnE,OAAOgC,GAAGA,CAACC,MAAM,EAAE;IACf,OAAOA,MAAM,CAACC,eAAe,CAAC9C,qBAAqB,CAAC+C,EAAE,CAAC;EAC3D;EACAC,WAAWA,CAACH,MAAM,EAAEI,oBAAoB,EAAEC,gBAAgB,EAAEC,iBAAiB,EAAEC,wBAAwB,EAAEC,kBAAkB,EAAEC,gBAAgB,EAAE;IAC3I,KAAK,CAAC,CAAC;IACP,IAAI,CAACJ,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACC,wBAAwB,GAAGA,wBAAwB;IACxD,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,OAAO,GAAGV,MAAM;IACrB,MAAMW,SAAS,GAAGX,MAAM,CAACY,mBAAmB,CAAC,CAAC;IAC9C,IAAI,CAACC,SAAS,CAACzD,qBAAqB,CAACuD,SAAS,EAAE,MAAM,EAAEG,CAAC,IAAI,IAAI,CAACC,UAAU,CAACD,CAAC,CAAC,CAAC,CAAC;IACjF,IAAI,CAACD,SAAS,CAACzD,qBAAqB,CAACuD,SAAS,EAAE,KAAK,EAAEG,CAAC,IAAI,IAAI,CAACC,UAAU,CAACD,CAAC,CAAC,CAAC,CAAC;IAChF,IAAI,CAACD,SAAS,CAACzD,qBAAqB,CAACuD,SAAS,EAAE,OAAO,EAAEG,CAAC,IAAI,IAAI,CAACE,WAAW,CAACF,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IACzF,IAAI,CAACG,qBAAqB,GAAG,IAAI,CAACJ,SAAS,CAAC,IAAI9B,qBAAqB,CAAC,iBAAiB,EAAEiB,MAAM,EAAEI,oBAAoB,CAAC,CAAC;IACvH,IAAI,CAACc,uBAAuB,GAAG,IAAI,CAACL,SAAS,CAACT,oBAAoB,CAACe,cAAc,CAAC5B,qBAAqB,EAAE,iBAAiB,EAAES,MAAM,EAAEL,qBAAqB,EAAE;MAAEyB,EAAE,EAAE1B,wBAAwB;MAAE2B,KAAK,EAAEpC,QAAQ,CAAC,sBAAsB,EAAE,uBAAuB;IAAE,CAAC,CAAC,CAAC;EACnQ;EACAqC,eAAeA,CAAA,EAAG;IACd,IAAI,CAACJ,uBAAuB,CAACK,eAAe,CAAC,CAAC;EAClD;EACAC,OAAOA,CAACC,SAAS,EAAE;IACf,IAAI,CAACf,OAAO,CAACgB,KAAK,CAAC,CAAC;IACpB,IAAI;MACA,IAAI,CAACC,qBAAqB,GAAG;QAAEF;MAAU,CAAC;MAC1CpE,iBAAiB,CAAC,CAAC,CAACuE,WAAW,CAAC,OAAO,CAAC;IAC5C,CAAC,SACO;MACJ,IAAI,CAACD,qBAAqB,GAAGE,SAAS;IAC1C;EACJ;EACAC,YAAYA,CAAA,EAAG;IACX,IAAI,CAACZ,uBAAuB,CAACa,KAAK,CAAC,CAAC;EACxC;EACAC,gBAAgBA,CAAA,EAAG;IACf,OAAO,IAAI,CAACtB,OAAO,CAACuB,SAAS,CAAC,EAAE,CAAC,0BAA0B,CAAC,CAACC,OAAO;EACxE;EACA,MAAMC,aAAaA,CAAA,EAAG;IAClB,MAAM,IAAI,CAACC,sBAAsB;EACrC;EACArB,UAAUA,CAACD,CAAC,EAAE;IACV,IAAI,CAAC,IAAI,CAACJ,OAAO,CAAC2B,YAAY,CAAC,CAAC,EAAE;MAC9B;IACJ;IACA;IACA;IACA;IACA,IAAI,CAAC/B,iBAAiB,CAACgC,kBAAkB,GAAG,CAAC;IAC7C,IAAI,CAACxB,CAAC,CAACyB,aAAa,IAAI,CAAC,IAAI,CAACP,gBAAgB,CAAC,CAAC,EAAE;MAC9C;IACJ;IACA,MAAMQ,KAAK,GAAG,IAAI,CAAC9B,OAAO,CAAC+B,QAAQ,CAAC,CAAC;IACrC,MAAMC,UAAU,GAAG,IAAI,CAAChC,OAAO,CAACiC,aAAa,CAAC,CAAC;IAC/C,IAAI,CAACH,KAAK,IAAI,CAACE,UAAU,EAAEnG,MAAM,EAAE;MAC/B;IACJ;IACA,MAAMqG,6BAA6B,GAAG,IAAI,CAAClC,OAAO,CAACuB,SAAS,CAAC,EAAE,CAAC,0CAA0C,CAAC;IAC3G,IAAIY,MAAM,GAAGH,UAAU;IACvB,MAAMI,qBAAqB,GAAGJ,UAAU,CAACnG,MAAM,KAAK,CAAC,IAAImG,UAAU,CAAC,CAAC,CAAC,CAACK,OAAO,CAAC,CAAC;IAChF,IAAID,qBAAqB,EAAE;MACvB,IAAI,CAACF,6BAA6B,EAAE;QAChC;MACJ;MACAC,MAAM,GAAG,CAAC,IAAIrE,KAAK,CAACqE,MAAM,CAAC,CAAC,CAAC,CAACG,eAAe,EAAE,CAAC,EAAEH,MAAM,CAAC,CAAC,CAAC,CAACG,eAAe,EAAE,CAAC,GAAGR,KAAK,CAACS,aAAa,CAACJ,MAAM,CAAC,CAAC,CAAC,CAACG,eAAe,CAAC,CAAC,CAAC;IACrI;IACA,MAAME,MAAM,GAAG,IAAI,CAACxC,OAAO,CAACyC,aAAa,CAAC,CAAC,EAAEC,kBAAkB,CAACV,UAAU,EAAEE,6BAA6B,EAAE1E,QAAQ,CAACmF,SAAS,CAAC;IAC9H,MAAMC,eAAe,GAAGC,KAAK,CAACC,OAAO,CAACN,MAAM,CAAC,GAAGA,MAAM,GAAG,IAAI;IAC7D,MAAMO,mBAAmB,GAAG;MACxBH,eAAe;MACfI,cAAc,EAAEZ,qBAAqB;MACrCa,IAAI,EAAE;IACV,CAAC;IACD,MAAMC,SAAS,GAAG,IAAI,CAACrD,wBAAwB,CAACsD,yBAAyB,CACpEC,OAAO,CAACtB,KAAK,CAAC,CACduB,MAAM,CAACC,CAAC,IAAI,CAAC,CAACA,CAAC,CAACC,oBAAoB,CAAC;IAC1C,IAAI,CAACL,SAAS,CAACrH,MAAM,EAAE;MACnB,IAAI,CAAC2H,eAAe,CAACpD,CAAC,CAACyB,aAAa,EAAE;QAAEkB;MAAoB,CAAC,CAAC;MAC9D;IACJ;IACA,MAAMU,YAAY,GAAG7F,gBAAgB,CAACwC,CAAC,CAACyB,aAAa,CAAC;IACtD,MAAM6B,qBAAqB,GAAGR,SAAS,CAACS,OAAO,CAACL,CAAC,IAAIA,CAAC,CAACM,aAAa,IAAI,EAAE,CAAC;IAC3E;IACA,MAAMC,MAAM,GAAGpG,YAAY,CAAC,CAAC;IAC7B,IAAI,CAAC+F,eAAe,CAACpD,CAAC,CAACyB,aAAa,EAAE;MAClCnB,EAAE,EAAEmD,MAAM;MACVH,qBAAqB;MACrBX;IACJ,CAAC,CAAC;IACF,MAAMe,OAAO,GAAGjH,uBAAuB,CAAC,MAAOkH,KAAK,IAAK;MACrD,MAAMC,OAAO,GAAGpH,QAAQ,CAAC,MAAMqH,OAAO,CAACC,GAAG,CAAChB,SAAS,CAACiB,GAAG,CAAC,MAAOC,QAAQ,IAAK;QACzE,IAAI;UACA,OAAO,MAAMA,QAAQ,CAACb,oBAAoB,CAACzB,KAAK,EAAEK,MAAM,EAAEsB,YAAY,EAAEM,KAAK,CAAC;QAClF,CAAC,CACD,OAAOM,GAAG,EAAE;UACRC,OAAO,CAACC,KAAK,CAACF,GAAG,CAAC;UAClB,OAAOlD,SAAS;QACpB;MACJ,CAAC,CAAC,CAAC,CAAC;MACJ;MACA;MACA6C,OAAO,CAACQ,OAAO,CAAC,CAAC;MACjB,KAAK,MAAMC,MAAM,IAAIT,OAAO,EAAE;QAC1B,KAAK,MAAM,CAACU,IAAI,EAAEC,KAAK,CAAC,IAAIF,MAAM,EAAE;UAChChB,YAAY,CAACmB,OAAO,CAACF,IAAI,EAAEC,KAAK,CAAC;QACrC;MACJ;MACA,OAAOlB,YAAY;IACvB,CAAC,CAAC;IACFhH,qBAAqB,CAACoI,qBAAqB,EAAEC,mBAAmB,CAACC,MAAM,CAAC,CAAC;IACzEtI,qBAAqB,CAACoI,qBAAqB,GAAG;MAAEhB,MAAM,EAAEA,MAAM;MAAEiB,mBAAmB,EAAEhB;IAAQ,CAAC;EAClG;EACA,MAAMxD,WAAWA,CAACF,CAAC,EAAE;IACjB,IAAI,CAACA,CAAC,CAACyB,aAAa,IAAI,CAAC,IAAI,CAAC7B,OAAO,CAAC2B,YAAY,CAAC,CAAC,EAAE;MAClD;IACJ;IACArD,iBAAiB,CAACe,GAAG,CAAC,IAAI,CAACW,OAAO,CAAC,EAAEgF,YAAY,CAAC,CAAC;IACnD,IAAI,CAACtD,sBAAsB,EAAEqD,MAAM,CAAC,CAAC;IACrC,IAAI,CAACrD,sBAAsB,GAAGP,SAAS;IACvC,MAAMW,KAAK,GAAG,IAAI,CAAC9B,OAAO,CAAC+B,QAAQ,CAAC,CAAC;IACrC,MAAMC,UAAU,GAAG,IAAI,CAAChC,OAAO,CAACiC,aAAa,CAAC,CAAC;IAC/C,IAAI,CAACD,UAAU,EAAEnG,MAAM,IAAI,CAACiG,KAAK,EAAE;MAC/B;IACJ;IACA,IAAI,IAAI,CAAC9B,OAAO,CAACuB,SAAS,CAAC,EAAE,CAAC,2BAA2B,CAAC,CAAC;IAAA,GACnD,CAAC,IAAI,CAACD,gBAAgB,CAAC,CAAC,IAAI,CAAC,IAAI,CAACL,qBAAsB,CAAC;IAAA,EAC/D;MACE;IACJ;IACA,MAAMgE,QAAQ,GAAG,IAAI,CAACC,iBAAiB,CAAC9E,CAAC,CAAC;IAC1C,MAAMqD,YAAY,GAAG9F,wBAAwB,CAACyC,CAAC,CAACyB,aAAa,CAAC;IAC9D4B,YAAY,CAAC0B,MAAM,CAACjG,mBAAmB,CAAC;IACxC,MAAMkG,qBAAqB,GAAG,CAC1B,GAAGhF,CAAC,CAACyB,aAAa,CAACwD,KAAK,EACxB,IAAGJ,QAAQ,EAAEvB,qBAAqB,IAAI,EAAE;IACxC;IACA;IACA;IACAnG,KAAK,CAAC+H,OAAO,CAChB;IACD,MAAMC,YAAY,GAAG,IAAI,CAAC1F,wBAAwB,CAACsD,yBAAyB,CACvEC,OAAO,CAACtB,KAAK,CAAC,CACduB,MAAM,CAACe,QAAQ,IAAI;MACpB;MACA,MAAMoB,UAAU,GAAG,IAAI,CAACvE,qBAAqB,EAAEF,SAAS;MACxD,IAAIyE,UAAU,EAAE;QACZ,IAAIpB,QAAQ,CAACqB,sBAAsB,IAAI,CAAC,IAAI,CAACC,yBAAyB,CAACtB,QAAQ,EAAEoB,UAAU,CAAC,EAAE;UAC1F,OAAO,KAAK;QAChB;MACJ;MACA;MACA,OAAOpB,QAAQ,CAACuB,cAAc,EAAEC,IAAI,CAACC,IAAI,IAAI1I,eAAe,CAAC0I,IAAI,EAAET,qBAAqB,CAAC,CAAC;IAC9F,CAAC,CAAC;IACF,IAAI,CAACG,YAAY,CAAC1J,MAAM,EAAE;MACtB,IAAI,IAAI,CAACoF,qBAAqB,EAAEF,SAAS,EAAE;QACvC,IAAI,CAAC+E,wBAAwB,CAAC9D,UAAU,EAAE,IAAI,CAACf,qBAAqB,CAACF,SAAS,CAAC;MACnF;MACA;IACJ;IACA;IACA;IACA;IACAX,CAAC,CAAC2F,cAAc,CAAC,CAAC;IAClB3F,CAAC,CAAC4F,wBAAwB,CAAC,CAAC;IAC5B,IAAI,IAAI,CAAC/E,qBAAqB,EAAE;MAC5B,IAAI,CAACgF,eAAe,CAAC,IAAI,CAAChF,qBAAqB,CAACF,SAAS,EAAEwE,YAAY,EAAEvD,UAAU,EAAEyB,YAAY,EAAEwB,QAAQ,CAAC;IAChH,CAAC,MACI;MACD,IAAI,CAACiB,aAAa,CAACX,YAAY,EAAEvD,UAAU,EAAEyB,YAAY,EAAEwB,QAAQ,EAAE7E,CAAC,CAAC;IAC3E;EACJ;EACA0F,wBAAwBA,CAAC9D,UAAU,EAAEwD,UAAU,EAAE;IAC7ClH,iBAAiB,CAACe,GAAG,CAAC,IAAI,CAACW,OAAO,CAAC,EAAEmG,WAAW,CAAC5H,QAAQ,CAAC,cAAc,EAAE,gCAAgC,EAAEiH,UAAU,YAAYpI,gBAAgB,GAAGoI,UAAU,CAACb,KAAK,GAAGa,UAAU,CAACY,UAAU,CAAC,EAAEpE,UAAU,CAAC,CAAC,CAAC,CAACqE,gBAAgB,CAAC,CAAC,CAAC;EACrO;EACAH,aAAaA,CAACX,YAAY,EAAEvD,UAAU,EAAEyB,YAAY,EAAEwB,QAAQ,EAAEqB,cAAc,EAAE;IAC5E,MAAMhH,MAAM,GAAG,IAAI,CAACU,OAAO;IAC3B,IAAI,CAACV,MAAM,CAACiH,QAAQ,CAAC,CAAC,EAAE;MACpB;IACJ;IACA,MAAMC,cAAc,GAAG,IAAIpI,kCAAkC,CAACkB,MAAM,EAAE,CAAC,CAAC,kCAAkC,CAAC,CAAC,qCAAqC6B,SAAS,CAAC;IAC3J,MAAMsF,CAAC,GAAG5J,uBAAuB,CAAC,MAAO6J,MAAM,IAAK;MAChD,MAAMpH,MAAM,GAAG,IAAI,CAACU,OAAO;MAC3B,IAAI,CAACV,MAAM,CAACiH,QAAQ,CAAC,CAAC,EAAE;QACpB;MACJ;MACA,MAAMzE,KAAK,GAAGxC,MAAM,CAACyC,QAAQ,CAAC,CAAC;MAC/B,MAAM4E,WAAW,GAAG,IAAIrJ,eAAe,CAAC,CAAC;MACzC,MAAMsJ,GAAG,GAAGD,WAAW,CAACE,GAAG,CAAC,IAAI7J,uBAAuB,CAAC0J,MAAM,CAAC,CAAC;MAChEC,WAAW,CAACE,GAAG,CAACL,cAAc,CAACzC,KAAK,CAAC+C,uBAAuB,CAAC,MAAMF,GAAG,CAAC7B,MAAM,CAAC,CAAC,CAAC,CAAC;MACjF,MAAMhB,KAAK,GAAG6C,GAAG,CAAC7C,KAAK;MACvB,IAAI;QACA,MAAM,IAAI,CAACgD,mBAAmB,CAACtD,YAAY,EAAEwB,QAAQ,EAAElB,KAAK,CAAC;QAC7D,IAAIA,KAAK,CAACiD,uBAAuB,EAAE;UAC/B;QACJ;QACA,MAAMC,kBAAkB,GAAG1B,YAAY,CAAClC,MAAM,CAACe,QAAQ,IAAI,IAAI,CAAC8C,wBAAwB,CAAC9C,QAAQ,EAAEX,YAAY,CAAC,CAAC;QACjH,IAAI,CAACwD,kBAAkB,CAACpL,MAAM,IACtBoL,kBAAkB,CAACpL,MAAM,KAAK,CAAC,IAAIoL,kBAAkB,CAAC,CAAC,CAAC,YAAYhJ,kCAAmC,CAAC;QAAA,EAC9G;UACE,OAAO,IAAI,CAACkJ,wBAAwB,CAAC1D,YAAY,EAAEwB,QAAQ,EAAElB,KAAK,EAAEuC,cAAc,CAAC;QACvF;QACA,MAAMc,OAAO,GAAG;UACZC,WAAW,EAAEtJ,wBAAwB,CAACuJ;QAC1C,CAAC;QACD,MAAMC,WAAW,GAAG,MAAM,IAAI,CAACC,aAAa,CAACP,kBAAkB,EAAExD,YAAY,EAAE3B,KAAK,EAAEE,UAAU,EAAEoF,OAAO,EAAErD,KAAK,CAAC;QACjH4C,WAAW,CAACE,GAAG,CAACU,WAAW,CAAC;QAC5B,IAAIxD,KAAK,CAACiD,uBAAuB,EAAE;UAC/B;QACJ;QACA;QACA,IAAIO,WAAW,CAACE,KAAK,CAAC5L,MAAM,KAAK,CAAC,IAAI0L,WAAW,CAACE,KAAK,CAAC,CAAC,CAAC,CAACrD,QAAQ,YAAYnG,kCAAkC,EAAE;UAC/G,OAAO,IAAI,CAACkJ,wBAAwB,CAAC1D,YAAY,EAAEwB,QAAQ,EAAElB,KAAK,EAAEuC,cAAc,CAAC;QACvF;QACA,IAAIiB,WAAW,CAACE,KAAK,CAAC5L,MAAM,EAAE;UAC1B,MAAM6L,aAAa,GAAGpI,MAAM,CAACiC,SAAS,CAAC,EAAE,CAAC,0BAA0B,CAAC,CAACoG,iBAAiB,KAAK,YAAY;UACxG,OAAO,IAAI,CAACnH,uBAAuB,CAACoH,wBAAwB,CAAC5F,UAAU,EAAE;YAAE6F,eAAe,EAAE,CAAC;YAAEC,QAAQ,EAAEP,WAAW,CAACE;UAAM,CAAC,EAAEC,aAAa,EAAE,CAACK,IAAI,EAAEhE,KAAK,KAAK;YAC1J,OAAO,IAAIE,OAAO,CAAC,CAAC+D,OAAO,EAAEC,MAAM,KAAK;cACpC,CAAC,YAAY;gBACT,IAAI;kBACA,MAAMC,QAAQ,GAAGH,IAAI,CAAC3D,QAAQ,CAAC+D,wBAAwB,GAAGJ,IAAI,EAAEhE,KAAK,CAAC;kBACtE,MAAMqE,KAAK,GAAG,IAAItL,eAAe,CAAC,CAAC;kBACnC,MAAMuL,QAAQ,GAAGH,QAAQ,KAAI,MAAM,IAAI,CAAC3H,qBAAqB,CAAC+H,SAAS,CAACtG,UAAU,CAAC,CAAC,CAAC,CAACuG,cAAc,CAAC,CAAC,EAAEhK,QAAQ,CAAC,gBAAgB,EAAE,uCAAuC,CAAC,EAAE0F,OAAO,CAACuE,IAAI,CAAC,CAACJ,KAAK,CAAC3B,CAAC,EAAEyB,QAAQ,CAAC,CAAC,EAAE;oBAC5MnD,MAAM,EAAEA,CAAA,KAAM;sBACVqD,KAAK,CAACrD,MAAM,CAAC,CAAC;sBACd,OAAOkD,MAAM,CAAC,IAAInJ,iBAAiB,CAAC,CAAC,CAAC;oBAC1C;kBACJ,CAAC,EAAE,CAAC,CAAC;kBACL,IAAIuJ,QAAQ,EAAE;oBACVN,IAAI,CAACU,cAAc,GAAGJ,QAAQ,CAACI,cAAc;kBACjD;kBACA,OAAOT,OAAO,CAACD,IAAI,CAAC;gBACxB,CAAC,CACD,OAAO1D,GAAG,EAAE;kBACR,OAAO4D,MAAM,CAAC5D,GAAG,CAAC;gBACtB;cACJ,CAAC,EAAE,CAAC;YACR,CAAC,CAAC;UACN,CAAC,EAAEN,KAAK,CAAC;QACb;QACA,MAAM,IAAI,CAACoD,wBAAwB,CAAC1D,YAAY,EAAEwB,QAAQ,EAAElB,KAAK,EAAEuC,cAAc,CAAC;MACtF,CAAC,SACO;QACJK,WAAW,CAAC+B,OAAO,CAAC,CAAC;QACrB,IAAI,IAAI,CAAChH,sBAAsB,KAAK+E,CAAC,EAAE;UACnC,IAAI,CAAC/E,sBAAsB,GAAGP,SAAS;QAC3C;MACJ;IACJ,CAAC,CAAC;IACF,IAAI,CAACZ,qBAAqB,CAAC+H,SAAS,CAACtG,UAAU,CAAC,CAAC,CAAC,CAACuG,cAAc,CAAC,CAAC,EAAEhK,QAAQ,CAAC,yBAAyB,EAAE,4DAA4D,CAAC,EAAEkI,CAAC,EAAE;MACvK1B,MAAM,EAAE,MAAAA,CAAA,KAAY;QAChB,IAAI;UACA0B,CAAC,CAAC1B,MAAM,CAAC,CAAC;UACV,IAAIyB,cAAc,CAACzC,KAAK,CAACiD,uBAAuB,EAAE;YAC9C;UACJ;UACA,MAAM,IAAI,CAACG,wBAAwB,CAAC1D,YAAY,EAAEwB,QAAQ,EAAEuB,cAAc,CAACzC,KAAK,EAAEuC,cAAc,CAAC;QACrG,CAAC,SACO;UACJE,cAAc,CAACkC,OAAO,CAAC,CAAC;QAC5B;MACJ;IACJ,CAAC,CAAC,CAACC,IAAI,CAAC,MAAM;MACVnC,cAAc,CAACkC,OAAO,CAAC,CAAC;IAC5B,CAAC,CAAC;IACF,IAAI,CAAChH,sBAAsB,GAAG+E,CAAC;EACnC;EACAR,eAAeA,CAACT,UAAU,EAAED,YAAY,EAAEvD,UAAU,EAAEyB,YAAY,EAAEwB,QAAQ,EAAE;IAC1E,MAAMwB,CAAC,GAAG5J,uBAAuB,CAAC,MAAOkH,KAAK,IAAK;MAC/C,MAAMzE,MAAM,GAAG,IAAI,CAACU,OAAO;MAC3B,IAAI,CAACV,MAAM,CAACiH,QAAQ,CAAC,CAAC,EAAE;QACpB;MACJ;MACA,MAAMzE,KAAK,GAAGxC,MAAM,CAACyC,QAAQ,CAAC,CAAC;MAC/B,MAAM4E,WAAW,GAAG,IAAIrJ,eAAe,CAAC,CAAC;MACzC,MAAMsL,WAAW,GAAGjC,WAAW,CAACE,GAAG,CAAC,IAAIzI,kCAAkC,CAACkB,MAAM,EAAE,CAAC,CAAC,kCAAkC,CAAC,CAAC,qCAAqC6B,SAAS,EAAE4C,KAAK,CAAC,CAAC;MAChL,IAAI;QACA,MAAM,IAAI,CAACgD,mBAAmB,CAACtD,YAAY,EAAEwB,QAAQ,EAAE2D,WAAW,CAAC7E,KAAK,CAAC;QACzE,IAAI6E,WAAW,CAAC7E,KAAK,CAACiD,uBAAuB,EAAE;UAC3C;QACJ;QACA;QACA,IAAIC,kBAAkB,GAAG1B,YAAY,CAAClC,MAAM,CAACe,QAAQ,IAAI,IAAI,CAAC8C,wBAAwB,CAAC9C,QAAQ,EAAEX,YAAY,EAAE+B,UAAU,CAAC,CAAC;QAC3H,IAAIA,UAAU,EAAE;UACZ;UACAyB,kBAAkB,GAAGA,kBAAkB,CAAC5D,MAAM,CAACe,QAAQ,IAAI,IAAI,CAACsB,yBAAyB,CAACtB,QAAQ,EAAEoB,UAAU,CAAC,CAAC;QACpH;QACA,MAAM4B,OAAO,GAAG;UACZC,WAAW,EAAEtJ,wBAAwB,CAAC8K,OAAO;UAC7CC,IAAI,EAAEtD,UAAU,IAAIA,UAAU,YAAYpI,gBAAgB,GAAGoI,UAAU,GAAGrE;QAC9E,CAAC;QACD,IAAIoG,WAAW,GAAGZ,WAAW,CAACE,GAAG,CAAC,MAAM,IAAI,CAACW,aAAa,CAACP,kBAAkB,EAAExD,YAAY,EAAE3B,KAAK,EAAEE,UAAU,EAAEoF,OAAO,EAAEwB,WAAW,CAAC7E,KAAK,CAAC,CAAC;QAC5I,IAAI6E,WAAW,CAAC7E,KAAK,CAACiD,uBAAuB,EAAE;UAC3C;QACJ;QACA;QACA,IAAIxB,UAAU,EAAE;UACZ+B,WAAW,GAAG;YACVE,KAAK,EAAEF,WAAW,CAACE,KAAK,CAACpE,MAAM,CAAC0E,IAAI,IAAI;cACpC,IAAIvC,UAAU,YAAYpI,gBAAgB,EAAE;gBACxC,OAAOoI,UAAU,CAACuD,QAAQ,CAAChB,IAAI,CAACiB,IAAI,CAAC;cACzC,CAAC,MACI;gBACD,OAAOxD,UAAU,CAACY,UAAU,KAAK2B,IAAI,CAAC3D,QAAQ,CAAC1D,EAAE;cACrD;YACJ,CAAC,CAAC;YACFgI,OAAO,EAAEnB,WAAW,CAACmB;UACzB,CAAC;QACL;QACA,IAAI,CAACnB,WAAW,CAACE,KAAK,CAAC5L,MAAM,EAAE;UAC3B,IAAIuL,OAAO,CAAC0B,IAAI,EAAE;YACd,IAAI,CAAChD,wBAAwB,CAAC9D,UAAU,EAAEoF,OAAO,CAAC0B,IAAI,CAAC;UAC3D;UACA;QACJ;QACA,IAAIG,UAAU;QACd,IAAIzD,UAAU,EAAE;UACZyD,UAAU,GAAG1B,WAAW,CAACE,KAAK,CAACyB,EAAE,CAAC,CAAC,CAAC;QACxC,CAAC,MACI;UACD,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAACrJ,kBAAkB,CAACsJ,IAAI,CAAC7B,WAAW,CAACE,KAAK,CAACtD,GAAG,CAAE4D,IAAI,KAAM;YACjFpH,KAAK,EAAEoH,IAAI,CAACsB,KAAK;YACjBC,WAAW,EAAEvB,IAAI,CAACiB,IAAI,EAAErE,KAAK;YAC7BoD;UACJ,CAAC,CAAC,CAAC,EAAE;YACDwB,WAAW,EAAEhL,QAAQ,CAAC,0BAA0B,EAAE,qBAAqB;UAC3E,CAAC,CAAC;UACF0K,UAAU,GAAGE,QAAQ,EAAEpB,IAAI;QAC/B;QACA,IAAI,CAACkB,UAAU,EAAE;UACb;QACJ;QACA,MAAMO,qBAAqB,GAAGtL,2BAA2B,CAAC4D,KAAK,CAAC2H,GAAG,EAAEzH,UAAU,EAAEiH,UAAU,CAAC;QAC5F,MAAM,IAAI,CAACtJ,gBAAgB,CAAC+J,KAAK,CAACF,qBAAqB,EAAE;UAAElK,MAAM,EAAE,IAAI,CAACU;QAAQ,CAAC,CAAC;MACtF,CAAC,SACO;QACJ2G,WAAW,CAAC+B,OAAO,CAAC,CAAC;QACrB,IAAI,IAAI,CAAChH,sBAAsB,KAAK+E,CAAC,EAAE;UACnC,IAAI,CAAC/E,sBAAsB,GAAGP,SAAS;QAC3C;MACJ;IACJ,CAAC,CAAC;IACF,IAAI,CAACpB,gBAAgB,CAAC4J,YAAY,CAAC;MAC/BC,QAAQ,EAAE,EAAE,CAAC;MACbP,KAAK,EAAE9K,QAAQ,CAAC,iBAAiB,EAAE,wBAAwB;IAC/D,CAAC,EAAE,MAAMkI,CAAC,CAAC;EACf;EACAjD,eAAeA,CAACC,YAAY,EAAEwB,QAAQ,EAAE;IACpCxB,YAAY,CAACoG,OAAO,CAAC3K,mBAAmB,EAAE4K,IAAI,CAACC,SAAS,CAAC9E,QAAQ,CAAC,CAAC;EACvE;EACAC,iBAAiBA,CAAC9E,CAAC,EAAE;IACjB,IAAI,CAACA,CAAC,CAACyB,aAAa,EAAE;MAClB;IACJ;IACA;IACA,MAAMmI,WAAW,GAAG5J,CAAC,CAACyB,aAAa,CAACoI,OAAO,CAAC/K,mBAAmB,CAAC;IAChE,IAAI8K,WAAW,EAAE;MACb,IAAI;QACA,OAAOF,IAAI,CAACI,KAAK,CAACF,WAAW,CAAC;MAClC,CAAC,CACD,MAAM;QACF,OAAO7I,SAAS;MACpB;IACJ;IACA;IACA,MAAM,CAACgJ,CAAC,EAAElF,QAAQ,CAAC,GAAGvH,mBAAmB,CAAC0M,WAAW,CAAChK,CAAC,CAACyB,aAAa,CAAC;IACtE,IAAIoD,QAAQ,EAAE;MACV,OAAO;QACHlC,mBAAmB,EAAE;UACjBE,IAAI,EAAEgC,QAAQ,CAAChC,IAAI;UACnBL,eAAe,EAAEqC,QAAQ,CAACrC,eAAe,IAAI,IAAI;UACjDI,cAAc,EAAE,CAAC,CAACiC,QAAQ,CAACoF;QAC/B;MACJ,CAAC;IACL;IACA,OAAOlJ,SAAS;EACpB;EACA,MAAM4F,mBAAmBA,CAACtD,YAAY,EAAEwB,QAAQ,EAAElB,KAAK,EAAE;IACrD,IAAIkB,QAAQ,EAAEvE,EAAE,IAAIjE,qBAAqB,CAACoI,qBAAqB,EAAEhB,MAAM,KAAKoB,QAAQ,CAACvE,EAAE,EAAE;MACrF,MAAM4J,mBAAmB,GAAG,MAAM7N,qBAAqB,CAACoI,qBAAqB,CAACC,mBAAmB;MACjG,IAAIf,KAAK,CAACiD,uBAAuB,EAAE;QAC/B;MACJ;MACA,KAAK,MAAM,CAACvL,GAAG,EAAEkJ,KAAK,CAAC,IAAI2F,mBAAmB,EAAE;QAC5C7G,YAAY,CAACmB,OAAO,CAACnJ,GAAG,EAAEkJ,KAAK,CAAC;MACpC;IACJ;IACA,IAAI,CAAClB,YAAY,CAAC8G,GAAG,CAAChN,KAAK,CAAC+H,OAAO,CAAC,EAAE;MAClC,MAAMkF,SAAS,GAAG,MAAM,IAAI,CAAC5K,iBAAiB,CAAC6K,aAAa,CAAC,CAAC;MAC9D,IAAI1G,KAAK,CAACiD,uBAAuB,EAAE;QAC/B;MACJ;MACA,IAAIwD,SAAS,CAAC3O,MAAM,EAAE;QAClB4H,YAAY,CAACiH,MAAM,CAACnN,KAAK,CAAC+H,OAAO,EAAEpI,4BAA4B,CAACD,OAAO,CAAC0N,MAAM,CAACH,SAAS,CAAC,CAAC,CAAC;MAC/F;IACJ;EACJ;EACA,MAAMhD,aAAaA,CAACtE,SAAS,EAAEO,YAAY,EAAE3B,KAAK,EAAEE,UAAU,EAAEoF,OAAO,EAAErD,KAAK,EAAE;IAC5E,MAAM4C,WAAW,GAAG,IAAIrJ,eAAe,CAAC,CAAC;IACzC,MAAM0G,OAAO,GAAG,MAAMjH,gBAAgB,CAACkH,OAAO,CAACC,GAAG,CAAChB,SAAS,CAACiB,GAAG,CAAC,MAAOC,QAAQ,IAAK;MACjF,IAAI;QACA,MAAMqD,KAAK,GAAG,MAAMrD,QAAQ,CAACwG,yBAAyB,GAAG9I,KAAK,EAAEE,UAAU,EAAEyB,YAAY,EAAE2D,OAAO,EAAErD,KAAK,CAAC;QACzG,IAAI0D,KAAK,EAAE;UACPd,WAAW,CAACE,GAAG,CAACY,KAAK,CAAC;QAC1B;QACA,OAAOA,KAAK,EAAEA,KAAK,EAAEtD,GAAG,CAAC4D,IAAI,KAAK;UAAE,GAAGA,IAAI;UAAE3D;QAAS,CAAC,CAAC,CAAC;MAC7D,CAAC,CACD,OAAOC,GAAG,EAAE;QACR,IAAI,CAACtF,mBAAmB,CAACsF,GAAG,CAAC,EAAE;UAC3BC,OAAO,CAACC,KAAK,CAACF,GAAG,CAAC;QACtB;QACA,OAAOlD,SAAS;MACpB;IACJ,CAAC,CAAC,CAAC,EAAE4C,KAAK,CAAC;IACX,MAAM0D,KAAK,GAAG7K,QAAQ,CAACoH,OAAO,IAAI,EAAE,CAAC,CAAC6G,IAAI,CAAC,CAAC,CAACxH,MAAM,CAAC0E,IAAI,IAAI;MACxD,OAAO,CAACX,OAAO,CAAC0B,IAAI,IAAI1B,OAAO,CAAC0B,IAAI,CAACC,QAAQ,CAAChB,IAAI,CAACiB,IAAI,CAAC;IAC5D,CAAC,CAAC;IACF,OAAO;MACHvB,KAAK,EAAEtJ,kBAAkB,CAACsJ,KAAK,CAAC;MAChCiB,OAAO,EAAEA,CAAA,KAAM/B,WAAW,CAAC+B,OAAO,CAAC;IACvC,CAAC;EACL;EACA,MAAMvB,wBAAwBA,CAAC1D,YAAY,EAAEwB,QAAQ,EAAElB,KAAK,EAAEuC,cAAc,EAAE;IAC1E,MAAMwE,gBAAgB,GAAGrH,YAAY,CAACpE,GAAG,CAAC9B,KAAK,CAACwN,IAAI,CAAC,IAAItH,YAAY,CAACpE,GAAG,CAAC,MAAM,CAAC;IACjF,MAAM0L,IAAI,GAAG,CAAC,MAAMD,gBAAgB,EAAEE,QAAQ,CAAC,CAAC,KAAK,EAAE;IACvD,IAAIjH,KAAK,CAACiD,uBAAuB,EAAE;MAC/B;IACJ;IACA,MAAMiE,OAAO,GAAG;MACZ3E,cAAc;MACdyE,IAAI;MACJ/H,cAAc,EAAEiC,QAAQ,EAAElC,mBAAmB,CAACC,cAAc,IAAI,KAAK;MACrEJ,eAAe,EAAEqC,QAAQ,EAAElC,mBAAmB,CAACH,eAAe,IAAI,IAAI;MACtEK,IAAI,EAAE;IACV,CAAC;IACD,IAAI,CAACjD,OAAO,CAACkL,OAAO,CAAC,UAAU,EAAE,OAAO,CAAC,qBAAqBD,OAAO,CAAC;EAC1E;EACA;AACJ;AACA;AACA;AACA;EACI/D,wBAAwBA,CAAC9C,QAAQ,EAAEX,YAAY,EAAE+B,UAAU,EAAE;IACzD,IAAI,CAACpB,QAAQ,CAACuB,cAAc,EAAEC,IAAI,CAACC,IAAI,IAAIpC,YAAY,CAAC0H,OAAO,CAACtF,IAAI,CAAC,CAAC,EAAE;MACpE,OAAO,KAAK;IAChB;IACA,OAAO,CAACL,UAAU,IAAI,IAAI,CAACE,yBAAyB,CAACtB,QAAQ,EAAEoB,UAAU,CAAC;EAC9E;EACAE,yBAAyBA,CAACtB,QAAQ,EAAEoB,UAAU,EAAE;IAC5C,IAAIA,UAAU,YAAYpI,gBAAgB,EAAE;MACxC,IAAI,CAACgH,QAAQ,CAACqB,sBAAsB,EAAE;QAClC,OAAO,IAAI;MACf;MACA,OAAOrB,QAAQ,CAACqB,sBAAsB,CAACG,IAAI,CAACwF,YAAY,IAAI5F,UAAU,CAACuD,QAAQ,CAACqC,YAAY,CAAC,CAAC;IAClG,CAAC,MACI;MACD,OAAOhH,QAAQ,CAAC1D,EAAE,KAAK8E,UAAU,CAACY,UAAU;IAChD;EACJ;AACJ,CAAC,EA3cY3J,qBAAqB,GAAA2C,oBAAO,EAC5BA,oBAAA,CAAKI,EAAE,GAAG,0CAA0C,EAAAJ,oBAAA,CA0chE;AACDD,mBAAmB,GAAG1C,qBAAqB,GAAGnB,UAAU,CAAC,CACrDgB,OAAO,CAAC,CAAC,EAAEoC,qBAAqB,CAAC,EACjCpC,OAAO,CAAC,CAAC,EAAEuB,gBAAgB,CAAC,EAC5BvB,OAAO,CAAC,CAAC,EAAEkC,iBAAiB,CAAC,EAC7BlC,OAAO,CAAC,CAAC,EAAE0B,wBAAwB,CAAC,EACpC1B,OAAO,CAAC,CAAC,EAAEsC,kBAAkB,CAAC,EAC9BtC,OAAO,CAAC,CAAC,EAAEqC,gBAAgB,CAAC,CAC/B,EAAEQ,mBAAmB,CAAC;AACvB,SAASA,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}