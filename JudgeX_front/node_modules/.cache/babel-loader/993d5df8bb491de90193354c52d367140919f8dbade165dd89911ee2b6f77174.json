{"ast":null,"code":"var _CompletionOptions;\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancellationError, isCancellationError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { FuzzyScore } from '../../../../base/common/filters.js';\nimport { DisposableStore, isDisposable } from '../../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\nimport { localize } from '../../../../nls.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { historyNavigationVisible } from '../../../../platform/history/browser/contextScopedHistoryWidget.js';\nexport const Context = {\n  Visible: historyNavigationVisible,\n  HasFocusedSuggestion: new RawContextKey('suggestWidgetHasFocusedSuggestion', false, localize('suggestWidgetHasSelection', \"Whether any suggestion is focused\")),\n  DetailsVisible: new RawContextKey('suggestWidgetDetailsVisible', false, localize('suggestWidgetDetailsVisible', \"Whether suggestion details are visible\")),\n  MultipleSuggestions: new RawContextKey('suggestWidgetMultipleSuggestions', false, localize('suggestWidgetMultipleSuggestions', \"Whether there are multiple suggestions to pick from\")),\n  MakesTextEdit: new RawContextKey('suggestionMakesTextEdit', true, localize('suggestionMakesTextEdit', \"Whether inserting the current suggestion yields in a change or has everything already been typed\")),\n  AcceptSuggestionsOnEnter: new RawContextKey('acceptSuggestionOnEnter', true, localize('acceptSuggestionOnEnter', \"Whether suggestions are inserted when pressing Enter\")),\n  HasInsertAndReplaceRange: new RawContextKey('suggestionHasInsertAndReplaceRange', false, localize('suggestionHasInsertAndReplaceRange', \"Whether the current suggestion has insert and replace behaviour\")),\n  InsertMode: new RawContextKey('suggestionInsertMode', undefined, {\n    type: 'string',\n    description: localize('suggestionInsertMode', \"Whether the default behaviour is to insert or replace\")\n  }),\n  CanResolve: new RawContextKey('suggestionCanResolve', false, localize('suggestionCanResolve', \"Whether the current suggestion supports to resolve further details\"))\n};\nexport const suggestWidgetStatusbarMenu = new MenuId('suggestWidgetStatusBar');\nexport class CompletionItem {\n  constructor(position, completion, container, provider) {\n    this.position = position;\n    this.completion = completion;\n    this.container = container;\n    this.provider = provider;\n    // validation\n    this.isInvalid = false;\n    // sorting, filtering\n    this.score = FuzzyScore.Default;\n    this.distance = 0;\n    this.textLabel = typeof completion.label === 'string' ? completion.label : completion.label?.label;\n    // ensure lower-variants (perf)\n    this.labelLow = this.textLabel.toLowerCase();\n    // validate label\n    this.isInvalid = !this.textLabel;\n    this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();\n    this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();\n    this.extensionId = completion.extensionId;\n    // normalize ranges\n    if (Range.isIRange(completion.range)) {\n      this.editStart = new Position(completion.range.startLineNumber, completion.range.startColumn);\n      this.editInsertEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);\n      this.editReplaceEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);\n      // validate range\n      this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range) || completion.range.startLineNumber !== position.lineNumber;\n    } else {\n      this.editStart = new Position(completion.range.insert.startLineNumber, completion.range.insert.startColumn);\n      this.editInsertEnd = new Position(completion.range.insert.endLineNumber, completion.range.insert.endColumn);\n      this.editReplaceEnd = new Position(completion.range.replace.endLineNumber, completion.range.replace.endColumn);\n      // validate ranges\n      this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range.insert) || Range.spansMultipleLines(completion.range.replace) || completion.range.insert.startLineNumber !== position.lineNumber || completion.range.replace.startLineNumber !== position.lineNumber || completion.range.insert.startColumn !== completion.range.replace.startColumn;\n    }\n    // create the suggestion resolver\n    if (typeof provider.resolveCompletionItem !== 'function') {\n      this._resolveCache = Promise.resolve();\n      this._resolveDuration = 0;\n    }\n  }\n  // ---- resolving\n  get isResolved() {\n    return this._resolveDuration !== undefined;\n  }\n  get resolveDuration() {\n    return this._resolveDuration !== undefined ? this._resolveDuration : -1;\n  }\n  async resolve(token) {\n    if (!this._resolveCache) {\n      const sub = token.onCancellationRequested(() => {\n        this._resolveCache = undefined;\n        this._resolveDuration = undefined;\n      });\n      const sw = new StopWatch(true);\n      this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then(value => {\n        Object.assign(this.completion, value);\n        this._resolveDuration = sw.elapsed();\n      }, err => {\n        if (isCancellationError(err)) {\n          // the IPC queue will reject the request with the\n          // cancellation error -> reset cached\n          this._resolveCache = undefined;\n          this._resolveDuration = undefined;\n        }\n      }).finally(() => {\n        sub.dispose();\n      });\n    }\n    return this._resolveCache;\n  }\n}\nexport class CompletionOptions {\n  constructor(snippetSortOrder = 2 /* SnippetSortOrder.Bottom */, kindFilter = new Set(), providerFilter = new Set(), providerItemsToReuse = new Map(), showDeprecated = true) {\n    this.snippetSortOrder = snippetSortOrder;\n    this.kindFilter = kindFilter;\n    this.providerFilter = providerFilter;\n    this.providerItemsToReuse = providerItemsToReuse;\n    this.showDeprecated = showDeprecated;\n  }\n}\n_CompletionOptions = CompletionOptions;\n_CompletionOptions.default = new _CompletionOptions();\nlet _snippetSuggestSupport;\nexport function getSnippetSuggestSupport() {\n  return _snippetSuggestSupport;\n}\nexport class CompletionItemModel {\n  constructor(items, needsClipboard, durations, disposable) {\n    this.items = items;\n    this.needsClipboard = needsClipboard;\n    this.durations = durations;\n    this.disposable = disposable;\n  }\n}\nexport async function provideSuggestionItems(registry, model, position, options = CompletionOptions.default, context = {\n  triggerKind: 0 /* languages.CompletionTriggerKind.Invoke */\n}, token = CancellationToken.None) {\n  const sw = new StopWatch();\n  position = position.clone();\n  const word = model.getWordAtPosition(position);\n  const defaultReplaceRange = word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range.fromPositions(position);\n  const defaultRange = {\n    replace: defaultReplaceRange,\n    insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column)\n  };\n  const result = [];\n  const disposables = new DisposableStore();\n  const durations = [];\n  let needsClipboard = false;\n  const onCompletionList = (provider, container, sw) => {\n    let didAddResult = false;\n    if (!container) {\n      return didAddResult;\n    }\n    for (const suggestion of container.suggestions) {\n      if (!options.kindFilter.has(suggestion.kind)) {\n        // skip if not showing deprecated suggestions\n        if (!options.showDeprecated && suggestion?.tags?.includes(1 /* languages.CompletionItemTag.Deprecated */)) {\n          continue;\n        }\n        // fill in default range when missing\n        if (!suggestion.range) {\n          suggestion.range = defaultRange;\n        }\n        // fill in default sortText when missing\n        if (!suggestion.sortText) {\n          suggestion.sortText = typeof suggestion.label === 'string' ? suggestion.label : suggestion.label.label;\n        }\n        if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4 /* languages.CompletionItemInsertTextRule.InsertAsSnippet */) {\n          needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);\n        }\n        result.push(new CompletionItem(position, suggestion, container, provider));\n        didAddResult = true;\n      }\n    }\n    if (isDisposable(container)) {\n      disposables.add(container);\n    }\n    durations.push({\n      providerName: provider._debugDisplayName ?? 'unknown_provider',\n      elapsedProvider: container.duration ?? -1,\n      elapsedOverall: sw.elapsed()\n    });\n    return didAddResult;\n  };\n  // ask for snippets in parallel to asking \"real\" providers. Only do something if configured to\n  // do so - no snippet filter, no special-providers-only request\n  const snippetCompletions = (async () => {\n    if (!_snippetSuggestSupport || options.kindFilter.has(27 /* languages.CompletionItemKind.Snippet */)) {\n      return;\n    }\n    // we have items from a previous session that we can reuse\n    const reuseItems = options.providerItemsToReuse.get(_snippetSuggestSupport);\n    if (reuseItems) {\n      reuseItems.forEach(item => result.push(item));\n      return;\n    }\n    if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {\n      return;\n    }\n    const sw = new StopWatch();\n    const list = await _snippetSuggestSupport.provideCompletionItems(model, position, context, token);\n    onCompletionList(_snippetSuggestSupport, list, sw);\n  })();\n  // add suggestions from contributed providers - providers are ordered in groups of\n  // equal score and once a group produces a result the process stops\n  // get provider groups, always add snippet suggestion provider\n  for (const providerGroup of registry.orderedGroups(model)) {\n    // for each support in the group ask for suggestions\n    let didAddResult = false;\n    await Promise.all(providerGroup.map(async provider => {\n      // we have items from a previous session that we can reuse\n      if (options.providerItemsToReuse.has(provider)) {\n        const items = options.providerItemsToReuse.get(provider);\n        items.forEach(item => result.push(item));\n        didAddResult = didAddResult || items.length > 0;\n        return;\n      }\n      // check if this provider is filtered out\n      if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {\n        return;\n      }\n      try {\n        const sw = new StopWatch();\n        const list = await provider.provideCompletionItems(model, position, context, token);\n        didAddResult = onCompletionList(provider, list, sw) || didAddResult;\n      } catch (err) {\n        onUnexpectedExternalError(err);\n      }\n    }));\n    if (didAddResult || token.isCancellationRequested) {\n      break;\n    }\n  }\n  await snippetCompletions;\n  if (token.isCancellationRequested) {\n    disposables.dispose();\n    return Promise.reject(new CancellationError());\n  }\n  return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, {\n    entries: durations,\n    elapsed: sw.elapsed()\n  }, disposables);\n}\nfunction defaultComparator(a, b) {\n  // check with 'sortText'\n  if (a.sortTextLow && b.sortTextLow) {\n    if (a.sortTextLow < b.sortTextLow) {\n      return -1;\n    } else if (a.sortTextLow > b.sortTextLow) {\n      return 1;\n    }\n  }\n  // check with 'label'\n  if (a.textLabel < b.textLabel) {\n    return -1;\n  } else if (a.textLabel > b.textLabel) {\n    return 1;\n  }\n  // check with 'type'\n  return a.completion.kind - b.completion.kind;\n}\nfunction snippetUpComparator(a, b) {\n  if (a.completion.kind !== b.completion.kind) {\n    if (a.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n      return -1;\n    } else if (b.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n      return 1;\n    }\n  }\n  return defaultComparator(a, b);\n}\nfunction snippetDownComparator(a, b) {\n  if (a.completion.kind !== b.completion.kind) {\n    if (a.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n      return 1;\n    } else if (b.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n      return -1;\n    }\n  }\n  return defaultComparator(a, b);\n}\nconst _snippetComparators = new Map();\n_snippetComparators.set(0 /* SnippetSortOrder.Top */, snippetUpComparator);\n_snippetComparators.set(2 /* SnippetSortOrder.Bottom */, snippetDownComparator);\n_snippetComparators.set(1 /* SnippetSortOrder.Inline */, defaultComparator);\nexport function getSuggestionComparator(snippetConfig) {\n  return _snippetComparators.get(snippetConfig);\n}\nCommandsRegistry.registerCommand('_executeCompletionItemProvider', async (accessor, ...args) => {\n  const [uri, position, triggerCharacter, maxItemsToResolve] = args;\n  assertType(URI.isUri(uri));\n  assertType(Position.isIPosition(position));\n  assertType(typeof triggerCharacter === 'string' || !triggerCharacter);\n  assertType(typeof maxItemsToResolve === 'number' || !maxItemsToResolve);\n  const {\n    completionProvider\n  } = accessor.get(ILanguageFeaturesService);\n  const ref = await accessor.get(ITextModelService).createModelReference(uri);\n  try {\n    const result = {\n      incomplete: false,\n      suggestions: []\n    };\n    const resolving = [];\n    const actualPosition = ref.object.textEditorModel.validatePosition(position);\n    const completions = await provideSuggestionItems(completionProvider, ref.object.textEditorModel, actualPosition, undefined, {\n      triggerCharacter: triggerCharacter ?? undefined,\n      triggerKind: triggerCharacter ? 1 /* languages.CompletionTriggerKind.TriggerCharacter */ : 0 /* languages.CompletionTriggerKind.Invoke */\n    });\n    for (const item of completions.items) {\n      if (resolving.length < (maxItemsToResolve ?? 0)) {\n        resolving.push(item.resolve(CancellationToken.None));\n      }\n      result.incomplete = result.incomplete || item.container.incomplete;\n      result.suggestions.push(item.completion);\n    }\n    try {\n      await Promise.all(resolving);\n      return result;\n    } finally {\n      setTimeout(() => completions.disposable.dispose(), 100);\n    }\n  } finally {\n    ref.dispose();\n  }\n});\nexport function showSimpleSuggestions(editor, provider) {\n  editor.getContribution('editor.contrib.suggestController')?.triggerSuggest(new Set().add(provider), undefined, true);\n}\nexport class QuickSuggestionsOptions {\n  static isAllOff(config) {\n    return config.other === 'off' && config.comments === 'off' && config.strings === 'off';\n  }\n  static isAllOn(config) {\n    return config.other === 'on' && config.comments === 'on' && config.strings === 'on';\n  }\n  static valueFor(config, tokenType) {\n    switch (tokenType) {\n      case 1 /* StandardTokenType.Comment */:\n        return config.comments;\n      case 2 /* StandardTokenType.String */:\n        return config.strings;\n      default:\n        return config.other;\n    }\n  }\n}","map":{"version":3,"names":["CancellationToken","CancellationError","isCancellationError","onUnexpectedExternalError","FuzzyScore","DisposableStore","isDisposable","StopWatch","assertType","URI","Position","Range","ITextModelService","SnippetParser","localize","MenuId","CommandsRegistry","RawContextKey","ILanguageFeaturesService","historyNavigationVisible","Context","Visible","HasFocusedSuggestion","DetailsVisible","MultipleSuggestions","MakesTextEdit","AcceptSuggestionsOnEnter","HasInsertAndReplaceRange","InsertMode","undefined","type","description","CanResolve","suggestWidgetStatusbarMenu","CompletionItem","constructor","position","completion","container","provider","isInvalid","score","Default","distance","textLabel","label","labelLow","toLowerCase","sortTextLow","sortText","filterTextLow","filterText","extensionId","isIRange","range","editStart","startLineNumber","startColumn","editInsertEnd","endLineNumber","endColumn","editReplaceEnd","spansMultipleLines","lineNumber","insert","replace","resolveCompletionItem","_resolveCache","Promise","resolve","_resolveDuration","isResolved","resolveDuration","token","sub","onCancellationRequested","sw","then","value","Object","assign","elapsed","err","finally","dispose","CompletionOptions","snippetSortOrder","kindFilter","Set","providerFilter","providerItemsToReuse","Map","showDeprecated","_CompletionOptions","default","_snippetSuggestSupport","getSnippetSuggestSupport","CompletionItemModel","items","needsClipboard","durations","disposable","provideSuggestionItems","registry","model","options","context","triggerKind","None","clone","word","getWordAtPosition","defaultReplaceRange","fromPositions","defaultRange","setEndPosition","column","result","disposables","onCompletionList","didAddResult","suggestion","suggestions","has","kind","tags","includes","insertTextRules","guessNeedsClipboard","insertText","push","add","providerName","_debugDisplayName","elapsedProvider","duration","elapsedOverall","snippetCompletions","reuseItems","get","forEach","item","size","list","provideCompletionItems","providerGroup","orderedGroups","all","map","length","isCancellationRequested","reject","sort","getSuggestionComparator","entries","defaultComparator","a","b","snippetUpComparator","snippetDownComparator","_snippetComparators","set","snippetConfig","registerCommand","accessor","args","uri","triggerCharacter","maxItemsToResolve","isUri","isIPosition","completionProvider","ref","createModelReference","incomplete","resolving","actualPosition","object","textEditorModel","validatePosition","completions","setTimeout","showSimpleSuggestions","editor","getContribution","triggerSuggest","QuickSuggestionsOptions","isAllOff","config","other","comments","strings","isAllOn","valueFor","tokenType"],"sources":["P:/WebStorm/judgex_front/node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggest.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { CancellationError, isCancellationError, onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { FuzzyScore } from '../../../../base/common/filters.js';\nimport { DisposableStore, isDisposable } from '../../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../../base/common/stopwatch.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { SnippetParser } from '../../snippet/browser/snippetParser.js';\nimport { localize } from '../../../../nls.js';\nimport { MenuId } from '../../../../platform/actions/common/actions.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { historyNavigationVisible } from '../../../../platform/history/browser/contextScopedHistoryWidget.js';\nexport const Context = {\n    Visible: historyNavigationVisible,\n    HasFocusedSuggestion: new RawContextKey('suggestWidgetHasFocusedSuggestion', false, localize('suggestWidgetHasSelection', \"Whether any suggestion is focused\")),\n    DetailsVisible: new RawContextKey('suggestWidgetDetailsVisible', false, localize('suggestWidgetDetailsVisible', \"Whether suggestion details are visible\")),\n    MultipleSuggestions: new RawContextKey('suggestWidgetMultipleSuggestions', false, localize('suggestWidgetMultipleSuggestions', \"Whether there are multiple suggestions to pick from\")),\n    MakesTextEdit: new RawContextKey('suggestionMakesTextEdit', true, localize('suggestionMakesTextEdit', \"Whether inserting the current suggestion yields in a change or has everything already been typed\")),\n    AcceptSuggestionsOnEnter: new RawContextKey('acceptSuggestionOnEnter', true, localize('acceptSuggestionOnEnter', \"Whether suggestions are inserted when pressing Enter\")),\n    HasInsertAndReplaceRange: new RawContextKey('suggestionHasInsertAndReplaceRange', false, localize('suggestionHasInsertAndReplaceRange', \"Whether the current suggestion has insert and replace behaviour\")),\n    InsertMode: new RawContextKey('suggestionInsertMode', undefined, { type: 'string', description: localize('suggestionInsertMode', \"Whether the default behaviour is to insert or replace\") }),\n    CanResolve: new RawContextKey('suggestionCanResolve', false, localize('suggestionCanResolve', \"Whether the current suggestion supports to resolve further details\")),\n};\nexport const suggestWidgetStatusbarMenu = new MenuId('suggestWidgetStatusBar');\nexport class CompletionItem {\n    constructor(position, completion, container, provider) {\n        this.position = position;\n        this.completion = completion;\n        this.container = container;\n        this.provider = provider;\n        // validation\n        this.isInvalid = false;\n        // sorting, filtering\n        this.score = FuzzyScore.Default;\n        this.distance = 0;\n        this.textLabel = typeof completion.label === 'string'\n            ? completion.label\n            : completion.label?.label;\n        // ensure lower-variants (perf)\n        this.labelLow = this.textLabel.toLowerCase();\n        // validate label\n        this.isInvalid = !this.textLabel;\n        this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();\n        this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();\n        this.extensionId = completion.extensionId;\n        // normalize ranges\n        if (Range.isIRange(completion.range)) {\n            this.editStart = new Position(completion.range.startLineNumber, completion.range.startColumn);\n            this.editInsertEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);\n            this.editReplaceEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);\n            // validate range\n            this.isInvalid = this.isInvalid\n                || Range.spansMultipleLines(completion.range) || completion.range.startLineNumber !== position.lineNumber;\n        }\n        else {\n            this.editStart = new Position(completion.range.insert.startLineNumber, completion.range.insert.startColumn);\n            this.editInsertEnd = new Position(completion.range.insert.endLineNumber, completion.range.insert.endColumn);\n            this.editReplaceEnd = new Position(completion.range.replace.endLineNumber, completion.range.replace.endColumn);\n            // validate ranges\n            this.isInvalid = this.isInvalid\n                || Range.spansMultipleLines(completion.range.insert) || Range.spansMultipleLines(completion.range.replace)\n                || completion.range.insert.startLineNumber !== position.lineNumber || completion.range.replace.startLineNumber !== position.lineNumber\n                || completion.range.insert.startColumn !== completion.range.replace.startColumn;\n        }\n        // create the suggestion resolver\n        if (typeof provider.resolveCompletionItem !== 'function') {\n            this._resolveCache = Promise.resolve();\n            this._resolveDuration = 0;\n        }\n    }\n    // ---- resolving\n    get isResolved() {\n        return this._resolveDuration !== undefined;\n    }\n    get resolveDuration() {\n        return this._resolveDuration !== undefined ? this._resolveDuration : -1;\n    }\n    async resolve(token) {\n        if (!this._resolveCache) {\n            const sub = token.onCancellationRequested(() => {\n                this._resolveCache = undefined;\n                this._resolveDuration = undefined;\n            });\n            const sw = new StopWatch(true);\n            this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then(value => {\n                Object.assign(this.completion, value);\n                this._resolveDuration = sw.elapsed();\n            }, err => {\n                if (isCancellationError(err)) {\n                    // the IPC queue will reject the request with the\n                    // cancellation error -> reset cached\n                    this._resolveCache = undefined;\n                    this._resolveDuration = undefined;\n                }\n            }).finally(() => {\n                sub.dispose();\n            });\n        }\n        return this._resolveCache;\n    }\n}\nexport class CompletionOptions {\n    static { this.default = new CompletionOptions(); }\n    constructor(snippetSortOrder = 2 /* SnippetSortOrder.Bottom */, kindFilter = new Set(), providerFilter = new Set(), providerItemsToReuse = new Map(), showDeprecated = true) {\n        this.snippetSortOrder = snippetSortOrder;\n        this.kindFilter = kindFilter;\n        this.providerFilter = providerFilter;\n        this.providerItemsToReuse = providerItemsToReuse;\n        this.showDeprecated = showDeprecated;\n    }\n}\nlet _snippetSuggestSupport;\nexport function getSnippetSuggestSupport() {\n    return _snippetSuggestSupport;\n}\nexport class CompletionItemModel {\n    constructor(items, needsClipboard, durations, disposable) {\n        this.items = items;\n        this.needsClipboard = needsClipboard;\n        this.durations = durations;\n        this.disposable = disposable;\n    }\n}\nexport async function provideSuggestionItems(registry, model, position, options = CompletionOptions.default, context = { triggerKind: 0 /* languages.CompletionTriggerKind.Invoke */ }, token = CancellationToken.None) {\n    const sw = new StopWatch();\n    position = position.clone();\n    const word = model.getWordAtPosition(position);\n    const defaultReplaceRange = word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range.fromPositions(position);\n    const defaultRange = { replace: defaultReplaceRange, insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column) };\n    const result = [];\n    const disposables = new DisposableStore();\n    const durations = [];\n    let needsClipboard = false;\n    const onCompletionList = (provider, container, sw) => {\n        let didAddResult = false;\n        if (!container) {\n            return didAddResult;\n        }\n        for (const suggestion of container.suggestions) {\n            if (!options.kindFilter.has(suggestion.kind)) {\n                // skip if not showing deprecated suggestions\n                if (!options.showDeprecated && suggestion?.tags?.includes(1 /* languages.CompletionItemTag.Deprecated */)) {\n                    continue;\n                }\n                // fill in default range when missing\n                if (!suggestion.range) {\n                    suggestion.range = defaultRange;\n                }\n                // fill in default sortText when missing\n                if (!suggestion.sortText) {\n                    suggestion.sortText = typeof suggestion.label === 'string' ? suggestion.label : suggestion.label.label;\n                }\n                if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4 /* languages.CompletionItemInsertTextRule.InsertAsSnippet */) {\n                    needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);\n                }\n                result.push(new CompletionItem(position, suggestion, container, provider));\n                didAddResult = true;\n            }\n        }\n        if (isDisposable(container)) {\n            disposables.add(container);\n        }\n        durations.push({\n            providerName: provider._debugDisplayName ?? 'unknown_provider', elapsedProvider: container.duration ?? -1, elapsedOverall: sw.elapsed()\n        });\n        return didAddResult;\n    };\n    // ask for snippets in parallel to asking \"real\" providers. Only do something if configured to\n    // do so - no snippet filter, no special-providers-only request\n    const snippetCompletions = (async () => {\n        if (!_snippetSuggestSupport || options.kindFilter.has(27 /* languages.CompletionItemKind.Snippet */)) {\n            return;\n        }\n        // we have items from a previous session that we can reuse\n        const reuseItems = options.providerItemsToReuse.get(_snippetSuggestSupport);\n        if (reuseItems) {\n            reuseItems.forEach(item => result.push(item));\n            return;\n        }\n        if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {\n            return;\n        }\n        const sw = new StopWatch();\n        const list = await _snippetSuggestSupport.provideCompletionItems(model, position, context, token);\n        onCompletionList(_snippetSuggestSupport, list, sw);\n    })();\n    // add suggestions from contributed providers - providers are ordered in groups of\n    // equal score and once a group produces a result the process stops\n    // get provider groups, always add snippet suggestion provider\n    for (const providerGroup of registry.orderedGroups(model)) {\n        // for each support in the group ask for suggestions\n        let didAddResult = false;\n        await Promise.all(providerGroup.map(async (provider) => {\n            // we have items from a previous session that we can reuse\n            if (options.providerItemsToReuse.has(provider)) {\n                const items = options.providerItemsToReuse.get(provider);\n                items.forEach(item => result.push(item));\n                didAddResult = didAddResult || items.length > 0;\n                return;\n            }\n            // check if this provider is filtered out\n            if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {\n                return;\n            }\n            try {\n                const sw = new StopWatch();\n                const list = await provider.provideCompletionItems(model, position, context, token);\n                didAddResult = onCompletionList(provider, list, sw) || didAddResult;\n            }\n            catch (err) {\n                onUnexpectedExternalError(err);\n            }\n        }));\n        if (didAddResult || token.isCancellationRequested) {\n            break;\n        }\n    }\n    await snippetCompletions;\n    if (token.isCancellationRequested) {\n        disposables.dispose();\n        return Promise.reject(new CancellationError());\n    }\n    return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, { entries: durations, elapsed: sw.elapsed() }, disposables);\n}\nfunction defaultComparator(a, b) {\n    // check with 'sortText'\n    if (a.sortTextLow && b.sortTextLow) {\n        if (a.sortTextLow < b.sortTextLow) {\n            return -1;\n        }\n        else if (a.sortTextLow > b.sortTextLow) {\n            return 1;\n        }\n    }\n    // check with 'label'\n    if (a.textLabel < b.textLabel) {\n        return -1;\n    }\n    else if (a.textLabel > b.textLabel) {\n        return 1;\n    }\n    // check with 'type'\n    return a.completion.kind - b.completion.kind;\n}\nfunction snippetUpComparator(a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n        if (a.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n            return -1;\n        }\n        else if (b.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n            return 1;\n        }\n    }\n    return defaultComparator(a, b);\n}\nfunction snippetDownComparator(a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n        if (a.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n            return 1;\n        }\n        else if (b.completion.kind === 27 /* languages.CompletionItemKind.Snippet */) {\n            return -1;\n        }\n    }\n    return defaultComparator(a, b);\n}\nconst _snippetComparators = new Map();\n_snippetComparators.set(0 /* SnippetSortOrder.Top */, snippetUpComparator);\n_snippetComparators.set(2 /* SnippetSortOrder.Bottom */, snippetDownComparator);\n_snippetComparators.set(1 /* SnippetSortOrder.Inline */, defaultComparator);\nexport function getSuggestionComparator(snippetConfig) {\n    return _snippetComparators.get(snippetConfig);\n}\nCommandsRegistry.registerCommand('_executeCompletionItemProvider', async (accessor, ...args) => {\n    const [uri, position, triggerCharacter, maxItemsToResolve] = args;\n    assertType(URI.isUri(uri));\n    assertType(Position.isIPosition(position));\n    assertType(typeof triggerCharacter === 'string' || !triggerCharacter);\n    assertType(typeof maxItemsToResolve === 'number' || !maxItemsToResolve);\n    const { completionProvider } = accessor.get(ILanguageFeaturesService);\n    const ref = await accessor.get(ITextModelService).createModelReference(uri);\n    try {\n        const result = {\n            incomplete: false,\n            suggestions: []\n        };\n        const resolving = [];\n        const actualPosition = ref.object.textEditorModel.validatePosition(position);\n        const completions = await provideSuggestionItems(completionProvider, ref.object.textEditorModel, actualPosition, undefined, { triggerCharacter: triggerCharacter ?? undefined, triggerKind: triggerCharacter ? 1 /* languages.CompletionTriggerKind.TriggerCharacter */ : 0 /* languages.CompletionTriggerKind.Invoke */ });\n        for (const item of completions.items) {\n            if (resolving.length < (maxItemsToResolve ?? 0)) {\n                resolving.push(item.resolve(CancellationToken.None));\n            }\n            result.incomplete = result.incomplete || item.container.incomplete;\n            result.suggestions.push(item.completion);\n        }\n        try {\n            await Promise.all(resolving);\n            return result;\n        }\n        finally {\n            setTimeout(() => completions.disposable.dispose(), 100);\n        }\n    }\n    finally {\n        ref.dispose();\n    }\n});\nexport function showSimpleSuggestions(editor, provider) {\n    editor.getContribution('editor.contrib.suggestController')?.triggerSuggest(new Set().add(provider), undefined, true);\n}\nexport class QuickSuggestionsOptions {\n    static isAllOff(config) {\n        return config.other === 'off' && config.comments === 'off' && config.strings === 'off';\n    }\n    static isAllOn(config) {\n        return config.other === 'on' && config.comments === 'on' && config.strings === 'on';\n    }\n    static valueFor(config, tokenType) {\n        switch (tokenType) {\n            case 1 /* StandardTokenType.Comment */: return config.comments;\n            case 2 /* StandardTokenType.String */: return config.strings;\n            default: return config.other;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}