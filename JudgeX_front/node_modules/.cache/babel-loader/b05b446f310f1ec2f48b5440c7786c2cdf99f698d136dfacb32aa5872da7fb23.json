{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { IndentAction } from './languageConfiguration.js';\nimport { IndentationContextProcessor, isLanguageDifferentFromLineStart, ProcessedIndentRulesSupport } from './supports/indentationLineProcessor.js';\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model, lineNumber, processedIndentRulesSupport) {\n  const languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n  if (lineNumber > 1) {\n    let lastLineNumber;\n    let resultLineNumber = -1;\n    for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n      if (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n        return resultLineNumber;\n      }\n      const text = model.getLineContent(lastLineNumber);\n      if (processedIndentRulesSupport.shouldIgnore(lastLineNumber) || /^\\s+$/.test(text) || text === '') {\n        resultLineNumber = lastLineNumber;\n        continue;\n      }\n      return lastLineNumber;\n    }\n  }\n  return -1;\n}\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true, languageConfigurationService) {\n  if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n    return null;\n  }\n  const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n  if (!indentRulesSupport) {\n    return null;\n  }\n  const processedIndentRulesSupport = new ProcessedIndentRulesSupport(model, indentRulesSupport, languageConfigurationService);\n  if (lineNumber <= 1) {\n    return {\n      indentation: '',\n      action: null\n    };\n  }\n  // Use no indent if this is the first non-blank line\n  for (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {\n    if (model.getLineContent(priorLineNumber) !== '') {\n      break;\n    }\n    if (priorLineNumber === 1) {\n      return {\n        indentation: '',\n        action: null\n      };\n    }\n  }\n  const precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, processedIndentRulesSupport);\n  if (precedingUnIgnoredLine < 0) {\n    return null;\n  } else if (precedingUnIgnoredLine < 1) {\n    return {\n      indentation: '',\n      action: null\n    };\n  }\n  if (processedIndentRulesSupport.shouldIncrease(precedingUnIgnoredLine) || processedIndentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLine)) {\n    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n    return {\n      indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n      action: IndentAction.Indent,\n      line: precedingUnIgnoredLine\n    };\n  } else if (processedIndentRulesSupport.shouldDecrease(precedingUnIgnoredLine)) {\n    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n    return {\n      indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n      action: null,\n      line: precedingUnIgnoredLine\n    };\n  } else {\n    // precedingUnIgnoredLine can not be ignored.\n    // it doesn't increase indent of following lines\n    // it doesn't increase just next line\n    // so current line is not affect by precedingUnIgnoredLine\n    // and then we should get a correct inheritted indentation from above lines\n    if (precedingUnIgnoredLine === 1) {\n      return {\n        indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n        action: null,\n        line: precedingUnIgnoredLine\n      };\n    }\n    const previousLine = precedingUnIgnoredLine - 1;\n    const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n    if (!(previousLineIndentMetadata & (1 /* IndentConsts.INCREASE_MASK */ | 2 /* IndentConsts.DECREASE_MASK */)) && previousLineIndentMetadata & 4 /* IndentConsts.INDENT_NEXTLINE_MASK */) {\n      let stopLine = 0;\n      for (let i = previousLine - 1; i > 0; i--) {\n        if (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n          continue;\n        }\n        stopLine = i;\n        break;\n      }\n      return {\n        indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n        action: null,\n        line: stopLine + 1\n      };\n    }\n    if (honorIntentialIndent) {\n      return {\n        indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n        action: null,\n        line: precedingUnIgnoredLine\n      };\n    } else {\n      // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n      for (let i = precedingUnIgnoredLine; i > 0; i--) {\n        if (processedIndentRulesSupport.shouldIncrease(i)) {\n          return {\n            indentation: strings.getLeadingWhitespace(model.getLineContent(i)),\n            action: IndentAction.Indent,\n            line: i\n          };\n        } else if (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n          let stopLine = 0;\n          for (let j = i - 1; j > 0; j--) {\n            if (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n              continue;\n            }\n            stopLine = j;\n            break;\n          }\n          return {\n            indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n            action: null,\n            line: stopLine + 1\n          };\n        } else if (processedIndentRulesSupport.shouldDecrease(i)) {\n          return {\n            indentation: strings.getLeadingWhitespace(model.getLineContent(i)),\n            action: null,\n            line: i\n          };\n        }\n      }\n      return {\n        indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n        action: null,\n        line: 1\n      };\n    }\n  }\n}\nexport function getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter, languageConfigurationService) {\n  if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n    return null;\n  }\n  const richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n  if (!richEditSupport) {\n    return null;\n  }\n  const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n  if (!indentRulesSupport) {\n    return null;\n  }\n  const processedIndentRulesSupport = new ProcessedIndentRulesSupport(virtualModel, indentRulesSupport, languageConfigurationService);\n  const indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n  if (indent) {\n    const inheritLine = indent.line;\n    if (inheritLine !== undefined) {\n      // Apply enter action as long as there are only whitespace lines between inherited line and this line.\n      let shouldApplyEnterRules = true;\n      for (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {\n        if (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n          shouldApplyEnterRules = false;\n          break;\n        }\n      }\n      if (shouldApplyEnterRules) {\n        const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n        if (enterResult) {\n          let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n          if (enterResult.removeText) {\n            indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n          }\n          if (enterResult.indentAction === IndentAction.Indent || enterResult.indentAction === IndentAction.IndentOutdent) {\n            indentation = indentConverter.shiftIndent(indentation);\n          } else if (enterResult.indentAction === IndentAction.Outdent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n          }\n          if (processedIndentRulesSupport.shouldDecrease(lineNumber)) {\n            indentation = indentConverter.unshiftIndent(indentation);\n          }\n          if (enterResult.appendText) {\n            indentation += enterResult.appendText;\n          }\n          return strings.getLeadingWhitespace(indentation);\n        }\n      }\n    }\n    if (processedIndentRulesSupport.shouldDecrease(lineNumber)) {\n      if (indent.action === IndentAction.Indent) {\n        return indent.indentation;\n      } else {\n        return indentConverter.unshiftIndent(indent.indentation);\n      }\n    } else {\n      if (indent.action === IndentAction.Indent) {\n        return indentConverter.shiftIndent(indent.indentation);\n      } else {\n        return indent.indentation;\n      }\n    }\n  }\n  return null;\n}\nexport function getIndentForEnter(autoIndent, model, range, indentConverter, languageConfigurationService) {\n  if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n    return null;\n  }\n  const languageId = model.getLanguageIdAtPosition(range.startLineNumber, range.startColumn);\n  const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n  if (!indentRulesSupport) {\n    return null;\n  }\n  model.tokenization.forceTokenization(range.startLineNumber);\n  const indentationContextProcessor = new IndentationContextProcessor(model, languageConfigurationService);\n  const processedContextTokens = indentationContextProcessor.getProcessedTokenContextAroundRange(range);\n  const afterEnterProcessedTokens = processedContextTokens.afterRangeProcessedTokens;\n  const beforeEnterProcessedTokens = processedContextTokens.beforeRangeProcessedTokens;\n  const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterProcessedTokens.getLineContent());\n  const virtualModel = createVirtualModelWithModifiedTokensAtLine(model, range.startLineNumber, beforeEnterProcessedTokens);\n  const languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(model, range.getStartPosition());\n  const currentLine = model.getLineContent(range.startLineNumber);\n  const currentLineIndent = strings.getLeadingWhitespace(currentLine);\n  const afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n  if (!afterEnterAction) {\n    const beforeEnter = languageIsDifferentFromLineStart ? currentLineIndent : beforeEnterIndent;\n    return {\n      beforeEnter: beforeEnter,\n      afterEnter: beforeEnter\n    };\n  }\n  let afterEnterIndent = languageIsDifferentFromLineStart ? currentLineIndent : afterEnterAction.indentation;\n  if (afterEnterAction.action === IndentAction.Indent) {\n    afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n  }\n  if (indentRulesSupport.shouldDecrease(afterEnterProcessedTokens.getLineContent())) {\n    afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n  }\n  return {\n    beforeEnter: languageIsDifferentFromLineStart ? currentLineIndent : beforeEnterIndent,\n    afterEnter: afterEnterIndent\n  };\n}\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(cursorConfig, model, range, ch, indentConverter, languageConfigurationService) {\n  const autoIndent = cursorConfig.autoIndent;\n  if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n    return null;\n  }\n  const languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(model, range.getStartPosition());\n  if (languageIsDifferentFromLineStart) {\n    // this line has mixed languages and indentation rules will not work\n    return null;\n  }\n  const languageId = model.getLanguageIdAtPosition(range.startLineNumber, range.startColumn);\n  const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n  if (!indentRulesSupport) {\n    return null;\n  }\n  const indentationContextProcessor = new IndentationContextProcessor(model, languageConfigurationService);\n  const processedContextTokens = indentationContextProcessor.getProcessedTokenContextAroundRange(range);\n  const beforeRangeText = processedContextTokens.beforeRangeProcessedTokens.getLineContent();\n  const afterRangeText = processedContextTokens.afterRangeProcessedTokens.getLineContent();\n  const textAroundRange = beforeRangeText + afterRangeText;\n  const textAroundRangeWithCharacter = beforeRangeText + ch + afterRangeText;\n  // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n  // Users might change the indentation by purpose and we should honor that instead of readjusting.\n  if (!indentRulesSupport.shouldDecrease(textAroundRange) && indentRulesSupport.shouldDecrease(textAroundRangeWithCharacter)) {\n    // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n    // 1. Get inherited indent action\n    const r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n    if (!r) {\n      return null;\n    }\n    let indentation = r.indentation;\n    if (r.action !== IndentAction.Indent) {\n      indentation = indentConverter.unshiftIndent(indentation);\n    }\n    return indentation;\n  }\n  const previousLineNumber = range.startLineNumber - 1;\n  if (previousLineNumber > 0) {\n    const previousLine = model.getLineContent(previousLineNumber);\n    if (indentRulesSupport.shouldIndentNextLine(previousLine) && indentRulesSupport.shouldIncrease(textAroundRangeWithCharacter)) {\n      const inheritedIndentationData = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n      const inheritedIndentation = inheritedIndentationData?.indentation;\n      if (inheritedIndentation !== undefined) {\n        const currentLine = model.getLineContent(range.startLineNumber);\n        const actualCurrentIndentation = strings.getLeadingWhitespace(currentLine);\n        const inferredCurrentIndentation = indentConverter.shiftIndent(inheritedIndentation);\n        // If the inferred current indentation is not equal to the actual current indentation, then the indentation has been intentionally changed, in that case keep it\n        const inferredIndentationEqualsActual = inferredCurrentIndentation === actualCurrentIndentation;\n        const textAroundRangeContainsOnlyWhitespace = /^\\s*$/.test(textAroundRange);\n        const autoClosingPairs = cursorConfig.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        const autoClosingPairExists = autoClosingPairs && autoClosingPairs.length > 0;\n        const isChFirstNonWhitespaceCharacterAndInAutoClosingPair = autoClosingPairExists && textAroundRangeContainsOnlyWhitespace;\n        if (inferredIndentationEqualsActual && isChFirstNonWhitespaceCharacterAndInAutoClosingPair) {\n          return inheritedIndentation;\n        }\n      }\n    }\n  }\n  return null;\n}\nexport function getIndentMetadata(model, lineNumber, languageConfigurationService) {\n  const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n  if (!indentRulesSupport) {\n    return null;\n  }\n  if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n    return null;\n  }\n  return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\nfunction createVirtualModelWithModifiedTokensAtLine(model, modifiedLineNumber, modifiedTokens) {\n  const virtualModel = {\n    tokenization: {\n      getLineTokens: lineNumber => {\n        if (lineNumber === modifiedLineNumber) {\n          return modifiedTokens;\n        } else {\n          return model.tokenization.getLineTokens(lineNumber);\n        }\n      },\n      getLanguageId: () => {\n        return model.getLanguageId();\n      },\n      getLanguageIdAtPosition: (lineNumber, column) => {\n        return model.getLanguageIdAtPosition(lineNumber, column);\n      }\n    },\n    getLineContent: lineNumber => {\n      if (lineNumber === modifiedLineNumber) {\n        return modifiedTokens.getLineContent();\n      } else {\n        return model.getLineContent(lineNumber);\n      }\n    }\n  };\n  return virtualModel;\n}","map":{"version":3,"names":["strings","IndentAction","IndentationContextProcessor","isLanguageDifferentFromLineStart","ProcessedIndentRulesSupport","getPrecedingValidLine","model","lineNumber","processedIndentRulesSupport","languageId","tokenization","getLanguageIdAtPosition","lastLineNumber","resultLineNumber","text","getLineContent","shouldIgnore","test","getInheritIndentForLine","autoIndent","honorIntentialIndent","languageConfigurationService","indentRulesSupport","getLanguageConfiguration","getLanguageId","indentation","action","priorLineNumber","precedingUnIgnoredLine","shouldIncrease","shouldIndentNextLine","precedingUnIgnoredLineContent","getLeadingWhitespace","Indent","line","shouldDecrease","previousLine","previousLineIndentMetadata","getIndentMetadata","stopLine","i","j","getGoodIndentForLine","virtualModel","indentConverter","richEditSupport","indent","undefined","inheritLine","shouldApplyEnterRules","inBetweenLine","enterResult","onEnter","removeText","substring","length","indentAction","IndentOutdent","shiftIndent","Outdent","unshiftIndent","appendText","getIndentForEnter","range","startLineNumber","startColumn","forceTokenization","indentationContextProcessor","processedContextTokens","getProcessedTokenContextAroundRange","afterEnterProcessedTokens","afterRangeProcessedTokens","beforeEnterProcessedTokens","beforeRangeProcessedTokens","beforeEnterIndent","createVirtualModelWithModifiedTokensAtLine","languageIsDifferentFromLineStart","getStartPosition","currentLine","currentLineIndent","afterEnterAction","beforeEnter","afterEnter","afterEnterIndent","getIndentActionForType","cursorConfig","ch","beforeRangeText","afterRangeText","textAroundRange","textAroundRangeWithCharacter","r","previousLineNumber","inheritedIndentationData","inheritedIndentation","actualCurrentIndentation","inferredCurrentIndentation","inferredIndentationEqualsActual","textAroundRangeContainsOnlyWhitespace","autoClosingPairs","autoClosingPairsOpenByEnd","get","autoClosingPairExists","isChFirstNonWhitespaceCharacterAndInAutoClosingPair","getLineCount","modifiedLineNumber","modifiedTokens","getLineTokens","column"],"sources":["P:/WebStorm/judgex_front/node_modules/monaco-editor/esm/vs/editor/common/languages/autoIndent.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { IndentAction } from './languageConfiguration.js';\nimport { IndentationContextProcessor, isLanguageDifferentFromLineStart, ProcessedIndentRulesSupport } from './supports/indentationLineProcessor.js';\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model, lineNumber, processedIndentRulesSupport) {\n    const languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n    if (lineNumber > 1) {\n        let lastLineNumber;\n        let resultLineNumber = -1;\n        for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n            if (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n                return resultLineNumber;\n            }\n            const text = model.getLineContent(lastLineNumber);\n            if (processedIndentRulesSupport.shouldIgnore(lastLineNumber) || /^\\s+$/.test(text) || text === '') {\n                resultLineNumber = lastLineNumber;\n                continue;\n            }\n            return lastLineNumber;\n        }\n    }\n    return -1;\n}\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const processedIndentRulesSupport = new ProcessedIndentRulesSupport(model, indentRulesSupport, languageConfigurationService);\n    if (lineNumber <= 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    // Use no indent if this is the first non-blank line\n    for (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {\n        if (model.getLineContent(priorLineNumber) !== '') {\n            break;\n        }\n        if (priorLineNumber === 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n    }\n    const precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, processedIndentRulesSupport);\n    if (precedingUnIgnoredLine < 0) {\n        return null;\n    }\n    else if (precedingUnIgnoredLine < 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    if (processedIndentRulesSupport.shouldIncrease(precedingUnIgnoredLine) || processedIndentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLine)) {\n        const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: IndentAction.Indent,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else if (processedIndentRulesSupport.shouldDecrease(precedingUnIgnoredLine)) {\n        const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: null,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else {\n        // precedingUnIgnoredLine can not be ignored.\n        // it doesn't increase indent of following lines\n        // it doesn't increase just next line\n        // so current line is not affect by precedingUnIgnoredLine\n        // and then we should get a correct inheritted indentation from above lines\n        if (precedingUnIgnoredLine === 1) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        const previousLine = precedingUnIgnoredLine - 1;\n        const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n        if (!(previousLineIndentMetadata & (1 /* IndentConsts.INCREASE_MASK */ | 2 /* IndentConsts.DECREASE_MASK */)) &&\n            (previousLineIndentMetadata & 4 /* IndentConsts.INDENT_NEXTLINE_MASK */)) {\n            let stopLine = 0;\n            for (let i = previousLine - 1; i > 0; i--) {\n                if (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n                    continue;\n                }\n                stopLine = i;\n                break;\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                action: null,\n                line: stopLine + 1\n            };\n        }\n        if (honorIntentialIndent) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n            for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                if (processedIndentRulesSupport.shouldIncrease(i)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(i)),\n                        action: IndentAction.Indent,\n                        line: i\n                    };\n                }\n                else if (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n                    let stopLine = 0;\n                    for (let j = i - 1; j > 0; j--) {\n                        if (processedIndentRulesSupport.shouldIndentNextLine(i)) {\n                            continue;\n                        }\n                        stopLine = j;\n                        break;\n                    }\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                        action: null,\n                        line: stopLine + 1\n                    };\n                }\n                else if (processedIndentRulesSupport.shouldDecrease(i)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(i)),\n                        action: null,\n                        line: i\n                    };\n                }\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                action: null,\n                line: 1\n            };\n        }\n    }\n}\nexport function getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const processedIndentRulesSupport = new ProcessedIndentRulesSupport(virtualModel, indentRulesSupport, languageConfigurationService);\n    const indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n    if (indent) {\n        const inheritLine = indent.line;\n        if (inheritLine !== undefined) {\n            // Apply enter action as long as there are only whitespace lines between inherited line and this line.\n            let shouldApplyEnterRules = true;\n            for (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {\n                if (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n                    shouldApplyEnterRules = false;\n                    break;\n                }\n            }\n            if (shouldApplyEnterRules) {\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n                if (enterResult) {\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (processedIndentRulesSupport.shouldDecrease(lineNumber)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n        }\n        if (processedIndentRulesSupport.shouldDecrease(lineNumber)) {\n            if (indent.action === IndentAction.Indent) {\n                return indent.indentation;\n            }\n            else {\n                return indentConverter.unshiftIndent(indent.indentation);\n            }\n        }\n        else {\n            if (indent.action === IndentAction.Indent) {\n                return indentConverter.shiftIndent(indent.indentation);\n            }\n            else {\n                return indent.indentation;\n            }\n        }\n    }\n    return null;\n}\nexport function getIndentForEnter(autoIndent, model, range, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const languageId = model.getLanguageIdAtPosition(range.startLineNumber, range.startColumn);\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    model.tokenization.forceTokenization(range.startLineNumber);\n    const indentationContextProcessor = new IndentationContextProcessor(model, languageConfigurationService);\n    const processedContextTokens = indentationContextProcessor.getProcessedTokenContextAroundRange(range);\n    const afterEnterProcessedTokens = processedContextTokens.afterRangeProcessedTokens;\n    const beforeEnterProcessedTokens = processedContextTokens.beforeRangeProcessedTokens;\n    const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterProcessedTokens.getLineContent());\n    const virtualModel = createVirtualModelWithModifiedTokensAtLine(model, range.startLineNumber, beforeEnterProcessedTokens);\n    const languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(model, range.getStartPosition());\n    const currentLine = model.getLineContent(range.startLineNumber);\n    const currentLineIndent = strings.getLeadingWhitespace(currentLine);\n    const afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n    if (!afterEnterAction) {\n        const beforeEnter = languageIsDifferentFromLineStart ? currentLineIndent : beforeEnterIndent;\n        return {\n            beforeEnter: beforeEnter,\n            afterEnter: beforeEnter\n        };\n    }\n    let afterEnterIndent = languageIsDifferentFromLineStart ? currentLineIndent : afterEnterAction.indentation;\n    if (afterEnterAction.action === IndentAction.Indent) {\n        afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n    }\n    if (indentRulesSupport.shouldDecrease(afterEnterProcessedTokens.getLineContent())) {\n        afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n    }\n    return {\n        beforeEnter: languageIsDifferentFromLineStart ? currentLineIndent : beforeEnterIndent,\n        afterEnter: afterEnterIndent\n    };\n}\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(cursorConfig, model, range, ch, indentConverter, languageConfigurationService) {\n    const autoIndent = cursorConfig.autoIndent;\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const languageIsDifferentFromLineStart = isLanguageDifferentFromLineStart(model, range.getStartPosition());\n    if (languageIsDifferentFromLineStart) {\n        // this line has mixed languages and indentation rules will not work\n        return null;\n    }\n    const languageId = model.getLanguageIdAtPosition(range.startLineNumber, range.startColumn);\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const indentationContextProcessor = new IndentationContextProcessor(model, languageConfigurationService);\n    const processedContextTokens = indentationContextProcessor.getProcessedTokenContextAroundRange(range);\n    const beforeRangeText = processedContextTokens.beforeRangeProcessedTokens.getLineContent();\n    const afterRangeText = processedContextTokens.afterRangeProcessedTokens.getLineContent();\n    const textAroundRange = beforeRangeText + afterRangeText;\n    const textAroundRangeWithCharacter = beforeRangeText + ch + afterRangeText;\n    // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n    // Users might change the indentation by purpose and we should honor that instead of readjusting.\n    if (!indentRulesSupport.shouldDecrease(textAroundRange) && indentRulesSupport.shouldDecrease(textAroundRangeWithCharacter)) {\n        // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n        // 1. Get inherited indent action\n        const r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n        if (!r) {\n            return null;\n        }\n        let indentation = r.indentation;\n        if (r.action !== IndentAction.Indent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n        }\n        return indentation;\n    }\n    const previousLineNumber = range.startLineNumber - 1;\n    if (previousLineNumber > 0) {\n        const previousLine = model.getLineContent(previousLineNumber);\n        if (indentRulesSupport.shouldIndentNextLine(previousLine) && indentRulesSupport.shouldIncrease(textAroundRangeWithCharacter)) {\n            const inheritedIndentationData = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n            const inheritedIndentation = inheritedIndentationData?.indentation;\n            if (inheritedIndentation !== undefined) {\n                const currentLine = model.getLineContent(range.startLineNumber);\n                const actualCurrentIndentation = strings.getLeadingWhitespace(currentLine);\n                const inferredCurrentIndentation = indentConverter.shiftIndent(inheritedIndentation);\n                // If the inferred current indentation is not equal to the actual current indentation, then the indentation has been intentionally changed, in that case keep it\n                const inferredIndentationEqualsActual = inferredCurrentIndentation === actualCurrentIndentation;\n                const textAroundRangeContainsOnlyWhitespace = /^\\s*$/.test(textAroundRange);\n                const autoClosingPairs = cursorConfig.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n                const autoClosingPairExists = autoClosingPairs && autoClosingPairs.length > 0;\n                const isChFirstNonWhitespaceCharacterAndInAutoClosingPair = autoClosingPairExists && textAroundRangeContainsOnlyWhitespace;\n                if (inferredIndentationEqualsActual && isChFirstNonWhitespaceCharacterAndInAutoClosingPair) {\n                    return inheritedIndentation;\n                }\n            }\n        }\n    }\n    return null;\n}\nexport function getIndentMetadata(model, lineNumber, languageConfigurationService) {\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n        return null;\n    }\n    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\nfunction createVirtualModelWithModifiedTokensAtLine(model, modifiedLineNumber, modifiedTokens) {\n    const virtualModel = {\n        tokenization: {\n            getLineTokens: (lineNumber) => {\n                if (lineNumber === modifiedLineNumber) {\n                    return modifiedTokens;\n                }\n                else {\n                    return model.tokenization.getLineTokens(lineNumber);\n                }\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n        },\n        getLineContent: (lineNumber) => {\n            if (lineNumber === modifiedLineNumber) {\n                return modifiedTokens.getLineContent();\n            }\n            else {\n                return model.getLineContent(lineNumber);\n            }\n        }\n    };\n    return virtualModel;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}