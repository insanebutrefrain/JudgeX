{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar TokenizationTextModelPart_1;\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry, TreeSitterTokenizationRegistry } from '../languages.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { AbstractTokens, AttachedViewHandler } from './tokens.js';\nimport { TreeSitterTokens } from './treeSitterTokens.js';\nimport { ITreeSitterParserService } from '../services/treeSitterParserService.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n  constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {\n    super();\n    this._textModel = _textModel;\n    this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n    this._languageId = _languageId;\n    this._attachedViews = _attachedViews;\n    this._languageService = _languageService;\n    this._languageConfigurationService = _languageConfigurationService;\n    this._treeSitterService = _treeSitterService;\n    this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n    this._onDidChangeLanguage = this._register(new Emitter());\n    this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n    this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n    this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n    this._onDidChangeTokens = this._register(new Emitter());\n    this.onDidChangeTokens = this._onDidChangeTokens.event;\n    this._tokensDisposables = this._register(new DisposableStore());\n    this._register(this._languageConfigurationService.onDidChange(e => {\n      if (e.affects(this._languageId)) {\n        this._onDidChangeLanguageConfiguration.fire({});\n      }\n    }));\n    // We just look at registry changes to determine whether to use tree sitter.\n    // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n    // Adding a language to the setting will not need a reload, however.\n    this._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, e => e.changedLanguages.includes(this._languageId))(() => {\n      this.createPreferredTokenProvider();\n    }));\n    this.createPreferredTokenProvider();\n  }\n  createGrammarTokens() {\n    return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n  }\n  createTreeSitterTokens() {\n    return this._register(new TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));\n  }\n  createTokens(useTreeSitter) {\n    const needsReset = this._tokens !== undefined;\n    this._tokens?.dispose();\n    this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();\n    this._tokensDisposables.clear();\n    this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {\n      this._emitModelTokensChangedEvent(e);\n    }));\n    this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {\n      this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n    }));\n    if (needsReset) {\n      // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n      this._tokens.resetTokenization();\n    }\n  }\n  createPreferredTokenProvider() {\n    if (TreeSitterTokenizationRegistry.get(this._languageId)) {\n      if (!(this._tokens instanceof TreeSitterTokens)) {\n        this.createTokens(true);\n      }\n    } else {\n      if (!(this._tokens instanceof GrammarTokens)) {\n        this.createTokens(false);\n      }\n    }\n  }\n  handleLanguageConfigurationServiceChange(e) {\n    if (e.affects(this._languageId)) {\n      this._onDidChangeLanguageConfiguration.fire({});\n    }\n  }\n  handleDidChangeContent(e) {\n    if (e.isFlush) {\n      this._semanticTokens.flush();\n    } else if (!e.isEolChange) {\n      // We don't have to do anything on an EOL change\n      for (const c of e.changes) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n        this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n      }\n    }\n    this._tokens.handleDidChangeContent(e);\n  }\n  handleDidChangeAttached() {\n    this._tokens.handleDidChangeAttached();\n  }\n  /**\n   * Includes grammar and semantic tokens.\n   */\n  getLineTokens(lineNumber) {\n    this.validateLineNumber(lineNumber);\n    const syntacticTokens = this._tokens.getLineTokens(lineNumber);\n    return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n  }\n  _emitModelTokensChangedEvent(e) {\n    if (!this._textModel._isDisposing()) {\n      this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n      this._onDidChangeTokens.fire(e);\n    }\n  }\n  // #region Grammar Tokens\n  validateLineNumber(lineNumber) {\n    if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n  }\n  get hasTokens() {\n    return this._tokens.hasTokens;\n  }\n  resetTokenization() {\n    this._tokens.resetTokenization();\n  }\n  get backgroundTokenizationState() {\n    return this._tokens.backgroundTokenizationState;\n  }\n  forceTokenization(lineNumber) {\n    this.validateLineNumber(lineNumber);\n    this._tokens.forceTokenization(lineNumber);\n  }\n  hasAccurateTokensForLine(lineNumber) {\n    this.validateLineNumber(lineNumber);\n    return this._tokens.hasAccurateTokensForLine(lineNumber);\n  }\n  isCheapToTokenize(lineNumber) {\n    this.validateLineNumber(lineNumber);\n    return this._tokens.isCheapToTokenize(lineNumber);\n  }\n  tokenizeIfCheap(lineNumber) {\n    this.validateLineNumber(lineNumber);\n    this._tokens.tokenizeIfCheap(lineNumber);\n  }\n  getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n    return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n  }\n  tokenizeLineWithEdit(position, length, newText) {\n    return this._tokens.tokenizeLineWithEdit(position, length, newText);\n  }\n  // #endregion\n  // #region Semantic Tokens\n  setSemanticTokens(tokens, isComplete) {\n    this._semanticTokens.set(tokens, isComplete);\n    this._emitModelTokensChangedEvent({\n      semanticTokensApplied: tokens !== null,\n      ranges: [{\n        fromLineNumber: 1,\n        toLineNumber: this._textModel.getLineCount()\n      }]\n    });\n  }\n  hasCompleteSemanticTokens() {\n    return this._semanticTokens.isComplete();\n  }\n  hasSomeSemanticTokens() {\n    return !this._semanticTokens.isEmpty();\n  }\n  setPartialSemanticTokens(range, tokens) {\n    if (this.hasCompleteSemanticTokens()) {\n      return;\n    }\n    const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n    this._emitModelTokensChangedEvent({\n      semanticTokensApplied: true,\n      ranges: [{\n        fromLineNumber: changedRange.startLineNumber,\n        toLineNumber: changedRange.endLineNumber\n      }]\n    });\n  }\n  // #endregion\n  // #region Utility Methods\n  getWordAtPosition(_position) {\n    this.assertNotDisposed();\n    const position = this._textModel.validatePosition(_position);\n    const lineContent = this._textModel.getLineContent(position.lineNumber);\n    const lineTokens = this.getLineTokens(position.lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    // (1). First try checking right biased word\n    const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n    const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n    // Make sure the result touches the original passed in position\n    if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n      return rightBiasedWord;\n    }\n    // (2). Else, if we were at a language boundary, check the left biased word\n    if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n      // edge case, where `position` sits between two tokens belonging to two different languages\n      const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n      const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n      // Make sure the result touches the original passed in position\n      if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n        return leftBiasedWord;\n      }\n    }\n    return null;\n  }\n  getLanguageConfiguration(languageId) {\n    return this._languageConfigurationService.getLanguageConfiguration(languageId);\n  }\n  static _findLanguageBoundaries(lineTokens, tokenIndex) {\n    const languageId = lineTokens.getLanguageId(tokenIndex);\n    // go left until a different language is hit\n    let startOffset = 0;\n    for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n      startOffset = lineTokens.getStartOffset(i);\n    }\n    // go right until a different language is hit\n    let endOffset = lineTokens.getLineContent().length;\n    for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n      endOffset = lineTokens.getEndOffset(i);\n    }\n    return [startOffset, endOffset];\n  }\n  getWordUntilPosition(position) {\n    const wordAtPosition = this.getWordAtPosition(position);\n    if (!wordAtPosition) {\n      return {\n        word: '',\n        startColumn: position.column,\n        endColumn: position.column\n      };\n    }\n    return {\n      word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n      startColumn: wordAtPosition.startColumn,\n      endColumn: position.column\n    };\n  }\n  // #endregion\n  // #region Language Id handling\n  getLanguageId() {\n    return this._languageId;\n  }\n  getLanguageIdAtPosition(lineNumber, column) {\n    const position = this._textModel.validatePosition(new Position(lineNumber, column));\n    const lineTokens = this.getLineTokens(position.lineNumber);\n    return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n  }\n  setLanguageId(languageId, source = 'api') {\n    if (this._languageId === languageId) {\n      // There's nothing to do\n      return;\n    }\n    const e = {\n      oldLanguage: this._languageId,\n      newLanguage: languageId,\n      source\n    };\n    this._languageId = languageId;\n    this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n    this._tokens.resetTokenization();\n    this.createPreferredTokenProvider();\n    this._onDidChangeLanguage.fire(e);\n    this._onDidChangeLanguageConfiguration.fire({});\n  }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([__param(4, ILanguageService), __param(5, ILanguageConfigurationService), __param(6, ITreeSitterParserService)], TokenizationTextModelPart);\nexport { TokenizationTextModelPart };\nclass GrammarTokens extends AbstractTokens {\n  constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n    super(languageIdCodec, textModel, getLanguageId);\n    this._tokenizer = null;\n    this._defaultBackgroundTokenizer = null;\n    this._backgroundTokenizer = this._register(new MutableDisposable());\n    this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n    this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n    this._attachedViewStates = this._register(new DisposableMap());\n    this._register(TokenizationRegistry.onDidChange(e => {\n      const languageId = this.getLanguageId();\n      if (e.changedLanguages.indexOf(languageId) === -1) {\n        return;\n      }\n      this.resetTokenization();\n    }));\n    this.resetTokenization();\n    this._register(attachedViews.onDidChangeVisibleRanges(({\n      view,\n      state\n    }) => {\n      if (state) {\n        let existing = this._attachedViewStates.get(view);\n        if (!existing) {\n          existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n          this._attachedViewStates.set(view, existing);\n        }\n        existing.handleStateChange(state);\n      } else {\n        this._attachedViewStates.deleteAndDispose(view);\n      }\n    }));\n  }\n  resetTokenization(fireTokenChangeEvent = true) {\n    this._tokens.flush();\n    this._debugBackgroundTokens?.flush();\n    if (this._debugBackgroundStates) {\n      this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n    }\n    if (fireTokenChangeEvent) {\n      this._onDidChangeTokens.fire({\n        semanticTokensApplied: false,\n        ranges: [{\n          fromLineNumber: 1,\n          toLineNumber: this._textModel.getLineCount()\n        }]\n      });\n    }\n    const initializeTokenization = () => {\n      if (this._textModel.isTooLargeForTokenization()) {\n        return [null, null];\n      }\n      const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n      if (!tokenizationSupport) {\n        return [null, null];\n      }\n      let initialState;\n      try {\n        initialState = tokenizationSupport.getInitialState();\n      } catch (e) {\n        onUnexpectedError(e);\n        return [null, null];\n      }\n      return [tokenizationSupport, initialState];\n    };\n    const [tokenizationSupport, initialState] = initializeTokenization();\n    if (tokenizationSupport && initialState) {\n      this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n    } else {\n      this._tokenizer = null;\n    }\n    this._backgroundTokenizer.clear();\n    this._defaultBackgroundTokenizer = null;\n    if (this._tokenizer) {\n      const b = {\n        setTokens: tokens => {\n          this.setTokens(tokens);\n        },\n        backgroundTokenizationFinished: () => {\n          if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // We already did a full tokenization and don't go back to progressing.\n            return;\n          }\n          const newState = 2 /* BackgroundTokenizationState.Completed */;\n          this._backgroundTokenizationState = newState;\n          this._onDidChangeBackgroundTokenizationState.fire();\n        },\n        setEndState: (lineNumber, state) => {\n          if (!this._tokenizer) {\n            return;\n          }\n          const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n          // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n          if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n            this._tokenizer?.store.setEndState(lineNumber, state);\n          }\n        }\n      };\n      if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n        this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n      }\n      if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n        this._backgroundTokenizer.value = this._defaultBackgroundTokenizer = new DefaultBackgroundTokenizer(this._tokenizer, b);\n        this._defaultBackgroundTokenizer.handleChanges();\n      }\n      if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n        this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        this._debugBackgroundTokenizer.clear();\n        this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n          setTokens: tokens => {\n            this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n          },\n          backgroundTokenizationFinished() {\n            // NO OP\n          },\n          setEndState: (lineNumber, state) => {\n            this._debugBackgroundStates?.setEndState(lineNumber, state);\n          }\n        });\n      } else {\n        this._debugBackgroundTokens = undefined;\n        this._debugBackgroundStates = undefined;\n        this._debugBackgroundTokenizer.value = undefined;\n      }\n    }\n    this.refreshAllVisibleLineTokens();\n  }\n  handleDidChangeAttached() {\n    this._defaultBackgroundTokenizer?.handleChanges();\n  }\n  handleDidChangeContent(e) {\n    if (e.isFlush) {\n      // Don't fire the event, as the view might not have got the text change event yet\n      this.resetTokenization(false);\n    } else if (!e.isEolChange) {\n      // We don't have to do anything on an EOL change\n      for (const c of e.changes) {\n        const [eolCount, firstLineLength] = countEOL(c.text);\n        this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n        this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n      }\n      this._debugBackgroundStates?.acceptChanges(e.changes);\n      if (this._tokenizer) {\n        this._tokenizer.store.acceptChanges(e.changes);\n      }\n      this._defaultBackgroundTokenizer?.handleChanges();\n    }\n  }\n  setTokens(tokens) {\n    const {\n      changes\n    } = this._tokens.setMultilineTokens(tokens, this._textModel);\n    if (changes.length > 0) {\n      this._onDidChangeTokens.fire({\n        semanticTokensApplied: false,\n        ranges: changes\n      });\n    }\n    return {\n      changes: changes\n    };\n  }\n  refreshAllVisibleLineTokens() {\n    const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n    this.refreshRanges(ranges);\n  }\n  refreshRanges(ranges) {\n    for (const range of ranges) {\n      this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n    }\n  }\n  refreshRange(startLineNumber, endLineNumber) {\n    if (!this._tokenizer) {\n      return;\n    }\n    startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n    endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n    const builder = new ContiguousMultilineTokensBuilder();\n    const {\n      heuristicTokens\n    } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n    const changedTokens = this.setTokens(builder.finalize());\n    if (heuristicTokens) {\n      // We overrode tokens with heuristically computed ones.\n      // Because old states might get reused (thus stopping invalidation),\n      // we have to explicitly request the tokens for the changed ranges again.\n      for (const c of changedTokens.changes) {\n        this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n      }\n    }\n    this._defaultBackgroundTokenizer?.checkFinished();\n  }\n  forceTokenization(lineNumber) {\n    const builder = new ContiguousMultilineTokensBuilder();\n    this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n    this.setTokens(builder.finalize());\n    this._defaultBackgroundTokenizer?.checkFinished();\n  }\n  hasAccurateTokensForLine(lineNumber) {\n    if (!this._tokenizer) {\n      return true;\n    }\n    return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n  }\n  isCheapToTokenize(lineNumber) {\n    if (!this._tokenizer) {\n      return true;\n    }\n    return this._tokenizer.isCheapToTokenize(lineNumber);\n  }\n  getLineTokens(lineNumber) {\n    const lineText = this._textModel.getLineContent(lineNumber);\n    const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n    if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n      if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n        const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n          this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n        }\n      }\n    }\n    return result;\n  }\n  getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n    if (!this._tokenizer) {\n      return 0 /* StandardTokenType.Other */;\n    }\n    const position = this._textModel.validatePosition(new Position(lineNumber, column));\n    this.forceTokenization(position.lineNumber);\n    return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n  }\n  tokenizeLineWithEdit(position, length, newText) {\n    if (!this._tokenizer) {\n      return null;\n    }\n    const validatedPosition = this._textModel.validatePosition(position);\n    this.forceTokenization(validatedPosition.lineNumber);\n    return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n  }\n  get hasTokens() {\n    return this._tokens.hasTokens;\n  }\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","TokenizationTextModelPart_1","BugIndicatingError","onUnexpectedError","Emitter","Event","DisposableMap","DisposableStore","MutableDisposable","countEOL","LineRange","Position","getWordAtText","TokenizationRegistry","TreeSitterTokenizationRegistry","ILanguageService","ILanguageConfigurationService","TextModelPart","DefaultBackgroundTokenizer","TokenizerWithStateStoreAndTextModel","TrackingTokenizationStateStore","AbstractTokens","AttachedViewHandler","TreeSitterTokens","ITreeSitterParserService","ContiguousMultilineTokensBuilder","ContiguousTokensStore","SparseTokensStore","TokenizationTextModelPart","constructor","_textModel","_bracketPairsTextModelPart","_languageId","_attachedViews","_languageService","_languageConfigurationService","_treeSitterService","_semanticTokens","languageIdCodec","_onDidChangeLanguage","_register","onDidChangeLanguage","event","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","_tokensDisposables","onDidChange","e","affects","fire","filter","changedLanguages","includes","createPreferredTokenProvider","createGrammarTokens","GrammarTokens","createTreeSitterTokens","createTokens","useTreeSitter","needsReset","_tokens","undefined","dispose","clear","add","_emitModelTokensChangedEvent","onDidChangeBackgroundTokenizationState","handleDidChangeBackgroundTokenizationState","resetTokenization","get","handleLanguageConfigurationServiceChange","handleDidChangeContent","isFlush","flush","isEolChange","changes","eolCount","firstLineLength","lastLineLength","text","acceptEdit","range","charCodeAt","handleDidChangeAttached","getLineTokens","lineNumber","validateLineNumber","syntacticTokens","addSparseTokens","_isDisposing","handleDidChangeTokens","getLineCount","hasTokens","backgroundTokenizationState","forceTokenization","hasAccurateTokensForLine","isCheapToTokenize","tokenizeIfCheap","getTokenTypeIfInsertingCharacter","column","character","tokenizeLineWithEdit","position","newText","setSemanticTokens","tokens","isComplete","set","semanticTokensApplied","ranges","fromLineNumber","toLineNumber","hasCompleteSemanticTokens","hasSomeSemanticTokens","isEmpty","setPartialSemanticTokens","changedRange","validateRange","setPartial","startLineNumber","endLineNumber","getWordAtPosition","_position","assertNotDisposed","validatePosition","lineContent","getLineContent","lineTokens","tokenIndex","findTokenIndexAtOffset","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","getLanguageConfiguration","getLanguageId","getWordDefinition","substring","startColumn","endColumn","lbStartOffset","lbEndOffset","leftBiasedWord","languageId","startOffset","getStartOffset","endOffset","tokenCount","getCount","getEndOffset","getWordUntilPosition","wordAtPosition","word","substr","getLanguageIdAtPosition","setLanguageId","source","oldLanguage","newLanguage","handleDidChangeLanguage","textModel","attachedViews","_tokenizer","_defaultBackgroundTokenizer","_backgroundTokenizer","_languageIdCodec","_debugBackgroundTokenizer","_attachedViewStates","indexOf","onDidChangeVisibleRanges","view","state","existing","refreshRanges","lineRanges","handleStateChange","deleteAndDispose","fireTokenChangeEvent","_debugBackgroundTokens","_debugBackgroundStates","initializeTokenization","isTooLargeForTokenization","tokenizationSupport","initialState","getInitialState","b","setTokens","backgroundTokenizationFinished","_backgroundTokenizationState","newState","_onDidChangeBackgroundTokenizationState","setEndState","firstInvalidEndStateLineNumber","store","getFirstInvalidEndStateLineNumber","createBackgroundTokenizer","backgroundTokenizerShouldOnlyVerifyTokens","value","handleChanges","setMultilineTokens","refreshAllVisibleLineTokens","acceptChanges","joinMany","map","_","s","refreshRange","endLineNumberExclusive","Math","max","min","builder","heuristicTokens","tokenizeHeuristically","changedTokens","finalize","requestTokens","checkFinished","updateTokensUntilLine","lineText","result","getTokens","getFirstInvalidEndStateLineNumberOrMax","backgroundResult","equals","reportMismatchingTokens","validatedPosition"],"sources":["P:/IDEA/JudgeX/judgex_front/node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TokenizationTextModelPart_1;\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry, TreeSitterTokenizationRegistry } from '../languages.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { AbstractTokens, AttachedViewHandler } from './tokens.js';\nimport { TreeSitterTokens } from './treeSitterTokens.js';\nimport { ITreeSitterParserService } from '../services/treeSitterParserService.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {\n        super();\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._treeSitterService = _treeSitterService;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._tokensDisposables = this._register(new DisposableStore());\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        // We just look at registry changes to determine whether to use tree sitter.\n        // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n        // Adding a language to the setting will not need a reload, however.\n        this._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {\n            this.createPreferredTokenProvider();\n        }));\n        this.createPreferredTokenProvider();\n    }\n    createGrammarTokens() {\n        return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n    }\n    createTreeSitterTokens() {\n        return this._register(new TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));\n    }\n    createTokens(useTreeSitter) {\n        const needsReset = this._tokens !== undefined;\n        this._tokens?.dispose();\n        this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();\n        this._tokensDisposables.clear();\n        this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n        if (needsReset) {\n            // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n            this._tokens.resetTokenization();\n        }\n    }\n    createPreferredTokenProvider() {\n        if (TreeSitterTokenizationRegistry.get(this._languageId)) {\n            if (!(this._tokens instanceof TreeSitterTokens)) {\n                this.createTokens(true);\n            }\n        }\n        else {\n            if (!(this._tokens instanceof GrammarTokens)) {\n                this.createTokens(false);\n            }\n        }\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this._tokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this._tokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this._tokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n    resetTokenization() {\n        this._tokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this._tokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this._tokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokens.resetTokenization();\n        this.createPreferredTokenProvider();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([\n    __param(4, ILanguageService),\n    __param(5, ILanguageConfigurationService),\n    __param(6, ITreeSitterParserService)\n], TokenizationTextModelPart);\nexport { TokenizationTextModelPart };\nclass GrammarTokens extends AbstractTokens {\n    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n        super(languageIdCodec, textModel, getLanguageId);\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}