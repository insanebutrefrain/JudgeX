{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { getAllMethodNames } from '../../../base/common/objects.js';\nimport { EditorWorkerClient } from '../../browser/services/editorWorkerService.js';\nimport { standaloneEditorWorkerDescriptor } from './standaloneServices.js';\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker(modelService, opts) {\n  return new MonacoWebWorkerImpl(modelService, opts);\n}\nclass MonacoWebWorkerImpl extends EditorWorkerClient {\n  constructor(modelService, opts) {\n    const workerDescriptor = {\n      amdModuleId: standaloneEditorWorkerDescriptor.amdModuleId,\n      esmModuleLocation: standaloneEditorWorkerDescriptor.esmModuleLocation,\n      label: opts.label\n    };\n    super(workerDescriptor, opts.keepIdleModels || false, modelService);\n    this._foreignModuleId = opts.moduleId;\n    this._foreignModuleCreateData = opts.createData || null;\n    this._foreignModuleHost = opts.host || null;\n    this._foreignProxy = null;\n  }\n  // foreign host request\n  fhr(method, args) {\n    if (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== 'function') {\n      return Promise.reject(new Error('Missing method ' + method + ' or missing main thread foreign host.'));\n    }\n    try {\n      return Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  _getForeignProxy() {\n    if (!this._foreignProxy) {\n      this._foreignProxy = this._getProxy().then(proxy => {\n        const foreignHostMethods = this._foreignModuleHost ? getAllMethodNames(this._foreignModuleHost) : [];\n        return proxy.$loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then(foreignMethods => {\n          this._foreignModuleCreateData = null;\n          const proxyMethodRequest = (method, args) => {\n            return proxy.$fmr(method, args);\n          };\n          const createProxyMethod = (method, proxyMethodRequest) => {\n            return function () {\n              const args = Array.prototype.slice.call(arguments, 0);\n              return proxyMethodRequest(method, args);\n            };\n          };\n          const foreignProxy = {};\n          for (const foreignMethod of foreignMethods) {\n            foreignProxy[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);\n          }\n          return foreignProxy;\n        });\n      });\n    }\n    return this._foreignProxy;\n  }\n  getProxy() {\n    return this._getForeignProxy();\n  }\n  withSyncedResources(resources) {\n    return this.workerWithSyncedResources(resources).then(_ => this.getProxy());\n  }\n}","map":{"version":3,"names":["getAllMethodNames","EditorWorkerClient","standaloneEditorWorkerDescriptor","createWebWorker","modelService","opts","MonacoWebWorkerImpl","constructor","workerDescriptor","amdModuleId","esmModuleLocation","label","keepIdleModels","_foreignModuleId","moduleId","_foreignModuleCreateData","createData","_foreignModuleHost","host","_foreignProxy","fhr","method","args","Promise","reject","Error","resolve","apply","e","_getForeignProxy","_getProxy","then","proxy","foreignHostMethods","$loadForeignModule","foreignMethods","proxyMethodRequest","$fmr","createProxyMethod","Array","prototype","slice","call","arguments","foreignProxy","foreignMethod","getProxy","withSyncedResources","resources","workerWithSyncedResources","_"],"sources":["P:/WebStorm/judgex_front/node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneWebWorker.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { getAllMethodNames } from '../../../base/common/objects.js';\nimport { EditorWorkerClient } from '../../browser/services/editorWorkerService.js';\nimport { standaloneEditorWorkerDescriptor } from './standaloneServices.js';\n/**\n * Create a new web worker that has model syncing capabilities built in.\n * Specify an AMD module to load that will `create` an object that will be proxied.\n */\nexport function createWebWorker(modelService, opts) {\n    return new MonacoWebWorkerImpl(modelService, opts);\n}\nclass MonacoWebWorkerImpl extends EditorWorkerClient {\n    constructor(modelService, opts) {\n        const workerDescriptor = {\n            amdModuleId: standaloneEditorWorkerDescriptor.amdModuleId,\n            esmModuleLocation: standaloneEditorWorkerDescriptor.esmModuleLocation,\n            label: opts.label,\n        };\n        super(workerDescriptor, opts.keepIdleModels || false, modelService);\n        this._foreignModuleId = opts.moduleId;\n        this._foreignModuleCreateData = opts.createData || null;\n        this._foreignModuleHost = opts.host || null;\n        this._foreignProxy = null;\n    }\n    // foreign host request\n    fhr(method, args) {\n        if (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== 'function') {\n            return Promise.reject(new Error('Missing method ' + method + ' or missing main thread foreign host.'));\n        }\n        try {\n            return Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    _getForeignProxy() {\n        if (!this._foreignProxy) {\n            this._foreignProxy = this._getProxy().then((proxy) => {\n                const foreignHostMethods = this._foreignModuleHost ? getAllMethodNames(this._foreignModuleHost) : [];\n                return proxy.$loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then((foreignMethods) => {\n                    this._foreignModuleCreateData = null;\n                    const proxyMethodRequest = (method, args) => {\n                        return proxy.$fmr(method, args);\n                    };\n                    const createProxyMethod = (method, proxyMethodRequest) => {\n                        return function () {\n                            const args = Array.prototype.slice.call(arguments, 0);\n                            return proxyMethodRequest(method, args);\n                        };\n                    };\n                    const foreignProxy = {};\n                    for (const foreignMethod of foreignMethods) {\n                        foreignProxy[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);\n                    }\n                    return foreignProxy;\n                });\n            });\n        }\n        return this._foreignProxy;\n    }\n    getProxy() {\n        return this._getForeignProxy();\n    }\n    withSyncedResources(resources) {\n        return this.workerWithSyncedResources(resources).then(_ => this.getProxy());\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}