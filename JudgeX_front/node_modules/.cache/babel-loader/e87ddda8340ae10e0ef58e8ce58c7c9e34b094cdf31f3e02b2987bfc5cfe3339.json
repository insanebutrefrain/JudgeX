{"ast":null,"code":"var _BrowserClipboardService;\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar BrowserClipboardService_1;\nimport { isSafari, isWebkitWebView } from '../../../base/browser/browser.js';\nimport { $, addDisposableListener, getActiveDocument, getActiveWindow, isHTMLElement, onDidRegisterWindow } from '../../../base/browser/dom.js';\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nimport { ILogService } from '../../log/common/log.js';\n/**\n * Custom mime type used for storing a list of uris in the clipboard.\n *\n * Requires support for custom web clipboards https://github.com/w3c/clipboard-apis/pull/175\n */\nconst vscodeResourcesMime = 'application/vnd.code.resources';\nlet BrowserClipboardService = (_BrowserClipboardService = class BrowserClipboardService extends Disposable {\n  constructor(layoutService, logService) {\n    super();\n    this.layoutService = layoutService;\n    this.logService = logService;\n    this.mapTextToType = new Map(); // unsupported in web (only in-memory)\n    this.findText = ''; // unsupported in web (only in-memory)\n    this.resources = []; // unsupported in web (only in-memory)\n    this.resourcesStateHash = undefined;\n    if (isSafari || isWebkitWebView) {\n      this.installWebKitWriteTextWorkaround();\n    }\n    // Keep track of copy operations to reset our set of\n    // copied resources: since we keep resources in memory\n    // and not in the clipboard, we have to invalidate\n    // that state when the user copies other data.\n    this._register(Event.runAndSubscribe(onDidRegisterWindow, ({\n      window,\n      disposables\n    }) => {\n      disposables.add(addDisposableListener(window.document, 'copy', () => this.clearResourcesState()));\n    }, {\n      window: mainWindow,\n      disposables: this._store\n    }));\n  }\n  // In Safari, it has the following note:\n  //\n  // \"The request to write to the clipboard must be triggered during a user gesture.\n  // A call to clipboard.write or clipboard.writeText outside the scope of a user\n  // gesture(such as \"click\" or \"touch\" event handlers) will result in the immediate\n  // rejection of the promise returned by the API call.\"\n  // From: https://webkit.org/blog/10855/async-clipboard-api/\n  //\n  // Since extensions run in a web worker, and handle gestures in an asynchronous way,\n  // they are not classified by Safari as \"in response to a user gesture\" and will reject.\n  //\n  // This function sets up some handlers to work around that behavior.\n  installWebKitWriteTextWorkaround() {\n    const handler = () => {\n      const currentWritePromise = new DeferredPromise();\n      // Cancel the previous promise since we just created a new one in response to this new event\n      if (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {\n        this.webKitPendingClipboardWritePromise.cancel();\n      }\n      this.webKitPendingClipboardWritePromise = currentWritePromise;\n      // The ctor of ClipboardItem allows you to pass in a promise that will resolve to a string.\n      // This allows us to pass in a Promise that will either be cancelled by another event or\n      // resolved with the contents of the first call to this.writeText.\n      // see https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#parameters\n      getActiveWindow().navigator.clipboard.write([new ClipboardItem({\n        'text/plain': currentWritePromise.p\n      })]).catch(async err => {\n        if (!(err instanceof Error) || err.name !== 'NotAllowedError' || !currentWritePromise.isRejected) {\n          this.logService.error(err);\n        }\n      });\n    };\n    this._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({\n      container,\n      disposables\n    }) => {\n      disposables.add(addDisposableListener(container, 'click', handler));\n      disposables.add(addDisposableListener(container, 'keydown', handler));\n    }, {\n      container: this.layoutService.mainContainer,\n      disposables: this._store\n    }));\n  }\n  async writeText(text, type) {\n    // Clear resources given we are writing text\n    this.clearResourcesState();\n    // With type: only in-memory is supported\n    if (type) {\n      this.mapTextToType.set(type, text);\n      return;\n    }\n    if (this.webKitPendingClipboardWritePromise) {\n      // For Safari, we complete this Promise which allows the call to `navigator.clipboard.write()`\n      // above to resolve and successfully copy to the clipboard. If we let this continue, Safari\n      // would throw an error because this call stack doesn't appear to originate from a user gesture.\n      return this.webKitPendingClipboardWritePromise.complete(text);\n    }\n    // Guard access to navigator.clipboard with try/catch\n    // as we have seen DOMExceptions in certain browsers\n    // due to security policies.\n    try {\n      return await getActiveWindow().navigator.clipboard.writeText(text);\n    } catch (error) {\n      console.error(error);\n    }\n    // Fallback to textarea and execCommand solution\n    this.fallbackWriteText(text);\n  }\n  fallbackWriteText(text) {\n    const activeDocument = getActiveDocument();\n    const activeElement = activeDocument.activeElement;\n    const textArea = activeDocument.body.appendChild($('textarea', {\n      'aria-hidden': true\n    }));\n    textArea.style.height = '1px';\n    textArea.style.width = '1px';\n    textArea.style.position = 'absolute';\n    textArea.value = text;\n    textArea.focus();\n    textArea.select();\n    activeDocument.execCommand('copy');\n    if (isHTMLElement(activeElement)) {\n      activeElement.focus();\n    }\n    textArea.remove();\n  }\n  async readText(type) {\n    // With type: only in-memory is supported\n    if (type) {\n      return this.mapTextToType.get(type) || '';\n    }\n    // Guard access to navigator.clipboard with try/catch\n    // as we have seen DOMExceptions in certain browsers\n    // due to security policies.\n    try {\n      return await getActiveWindow().navigator.clipboard.readText();\n    } catch (error) {\n      console.error(error);\n    }\n    return '';\n  }\n  async readFindText() {\n    return this.findText;\n  }\n  async writeFindText(text) {\n    this.findText = text;\n  }\n  async readResources() {\n    // Guard access to navigator.clipboard with try/catch\n    // as we have seen DOMExceptions in certain browsers\n    // due to security policies.\n    try {\n      const items = await getActiveWindow().navigator.clipboard.read();\n      for (const item of items) {\n        if (item.types.includes(`web ${vscodeResourcesMime}`)) {\n          const blob = await item.getType(`web ${vscodeResourcesMime}`);\n          const resources = JSON.parse(await blob.text()).map(x => URI.from(x));\n          return resources;\n        }\n      }\n    } catch (error) {\n      // Noop\n    }\n    const resourcesStateHash = await this.computeResourcesStateHash();\n    if (this.resourcesStateHash !== resourcesStateHash) {\n      this.clearResourcesState(); // state mismatch, resources no longer valid\n    }\n    return this.resources;\n  }\n  async computeResourcesStateHash() {\n    if (this.resources.length === 0) {\n      return undefined; // no resources, no hash needed\n    }\n    // Resources clipboard is managed in-memory only and thus\n    // fails to invalidate when clipboard data is changing.\n    // As such, we compute the hash of the current clipboard\n    // and use that to later validate the resources clipboard.\n    const clipboardText = await this.readText();\n    return hash(clipboardText.substring(0, BrowserClipboardService_1.MAX_RESOURCE_STATE_SOURCE_LENGTH));\n  }\n  clearInternalState() {\n    this.clearResourcesState();\n  }\n  clearResourcesState() {\n    this.resources = [];\n    this.resourcesStateHash = undefined;\n  }\n}, BrowserClipboardService_1 = _BrowserClipboardService, _BrowserClipboardService.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1000, _BrowserClipboardService);\nBrowserClipboardService = BrowserClipboardService_1 = __decorate([__param(0, ILayoutService), __param(1, ILogService)], BrowserClipboardService);\nexport { BrowserClipboardService };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","BrowserClipboardService_1","isSafari","isWebkitWebView","$","addDisposableListener","getActiveDocument","getActiveWindow","isHTMLElement","onDidRegisterWindow","mainWindow","DeferredPromise","Event","hash","Disposable","URI","ILayoutService","ILogService","vscodeResourcesMime","BrowserClipboardService","_BrowserClipboardService","constructor","layoutService","logService","mapTextToType","Map","findText","resources","resourcesStateHash","undefined","installWebKitWriteTextWorkaround","_register","runAndSubscribe","window","disposables","add","document","clearResourcesState","_store","handler","currentWritePromise","webKitPendingClipboardWritePromise","isSettled","cancel","navigator","clipboard","write","ClipboardItem","p","catch","err","Error","name","isRejected","error","onDidAddContainer","container","mainContainer","writeText","text","type","set","complete","console","fallbackWriteText","activeDocument","activeElement","textArea","body","appendChild","style","height","width","position","value","focus","select","execCommand","remove","readText","get","readFindText","writeFindText","readResources","items","read","item","types","includes","blob","getType","JSON","parse","map","x","from","computeResourcesStateHash","clipboardText","substring","MAX_RESOURCE_STATE_SOURCE_LENGTH","clearInternalState"],"sources":["P:/WebStorm/judgex_front/node_modules/monaco-editor/esm/vs/platform/clipboard/browser/clipboardService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar BrowserClipboardService_1;\nimport { isSafari, isWebkitWebView } from '../../../base/browser/browser.js';\nimport { $, addDisposableListener, getActiveDocument, getActiveWindow, isHTMLElement, onDidRegisterWindow } from '../../../base/browser/dom.js';\nimport { mainWindow } from '../../../base/browser/window.js';\nimport { DeferredPromise } from '../../../base/common/async.js';\nimport { Event } from '../../../base/common/event.js';\nimport { hash } from '../../../base/common/hash.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ILayoutService } from '../../layout/browser/layoutService.js';\nimport { ILogService } from '../../log/common/log.js';\n/**\n * Custom mime type used for storing a list of uris in the clipboard.\n *\n * Requires support for custom web clipboards https://github.com/w3c/clipboard-apis/pull/175\n */\nconst vscodeResourcesMime = 'application/vnd.code.resources';\nlet BrowserClipboardService = class BrowserClipboardService extends Disposable {\n    static { BrowserClipboardService_1 = this; }\n    constructor(layoutService, logService) {\n        super();\n        this.layoutService = layoutService;\n        this.logService = logService;\n        this.mapTextToType = new Map(); // unsupported in web (only in-memory)\n        this.findText = ''; // unsupported in web (only in-memory)\n        this.resources = []; // unsupported in web (only in-memory)\n        this.resourcesStateHash = undefined;\n        if (isSafari || isWebkitWebView) {\n            this.installWebKitWriteTextWorkaround();\n        }\n        // Keep track of copy operations to reset our set of\n        // copied resources: since we keep resources in memory\n        // and not in the clipboard, we have to invalidate\n        // that state when the user copies other data.\n        this._register(Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => {\n            disposables.add(addDisposableListener(window.document, 'copy', () => this.clearResourcesState()));\n        }, { window: mainWindow, disposables: this._store }));\n    }\n    // In Safari, it has the following note:\n    //\n    // \"The request to write to the clipboard must be triggered during a user gesture.\n    // A call to clipboard.write or clipboard.writeText outside the scope of a user\n    // gesture(such as \"click\" or \"touch\" event handlers) will result in the immediate\n    // rejection of the promise returned by the API call.\"\n    // From: https://webkit.org/blog/10855/async-clipboard-api/\n    //\n    // Since extensions run in a web worker, and handle gestures in an asynchronous way,\n    // they are not classified by Safari as \"in response to a user gesture\" and will reject.\n    //\n    // This function sets up some handlers to work around that behavior.\n    installWebKitWriteTextWorkaround() {\n        const handler = () => {\n            const currentWritePromise = new DeferredPromise();\n            // Cancel the previous promise since we just created a new one in response to this new event\n            if (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {\n                this.webKitPendingClipboardWritePromise.cancel();\n            }\n            this.webKitPendingClipboardWritePromise = currentWritePromise;\n            // The ctor of ClipboardItem allows you to pass in a promise that will resolve to a string.\n            // This allows us to pass in a Promise that will either be cancelled by another event or\n            // resolved with the contents of the first call to this.writeText.\n            // see https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#parameters\n            getActiveWindow().navigator.clipboard.write([new ClipboardItem({\n                    'text/plain': currentWritePromise.p,\n                })]).catch(async (err) => {\n                if (!(err instanceof Error) || err.name !== 'NotAllowedError' || !currentWritePromise.isRejected) {\n                    this.logService.error(err);\n                }\n            });\n        };\n        this._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container, disposables }) => {\n            disposables.add(addDisposableListener(container, 'click', handler));\n            disposables.add(addDisposableListener(container, 'keydown', handler));\n        }, { container: this.layoutService.mainContainer, disposables: this._store }));\n    }\n    async writeText(text, type) {\n        // Clear resources given we are writing text\n        this.clearResourcesState();\n        // With type: only in-memory is supported\n        if (type) {\n            this.mapTextToType.set(type, text);\n            return;\n        }\n        if (this.webKitPendingClipboardWritePromise) {\n            // For Safari, we complete this Promise which allows the call to `navigator.clipboard.write()`\n            // above to resolve and successfully copy to the clipboard. If we let this continue, Safari\n            // would throw an error because this call stack doesn't appear to originate from a user gesture.\n            return this.webKitPendingClipboardWritePromise.complete(text);\n        }\n        // Guard access to navigator.clipboard with try/catch\n        // as we have seen DOMExceptions in certain browsers\n        // due to security policies.\n        try {\n            return await getActiveWindow().navigator.clipboard.writeText(text);\n        }\n        catch (error) {\n            console.error(error);\n        }\n        // Fallback to textarea and execCommand solution\n        this.fallbackWriteText(text);\n    }\n    fallbackWriteText(text) {\n        const activeDocument = getActiveDocument();\n        const activeElement = activeDocument.activeElement;\n        const textArea = activeDocument.body.appendChild($('textarea', { 'aria-hidden': true }));\n        textArea.style.height = '1px';\n        textArea.style.width = '1px';\n        textArea.style.position = 'absolute';\n        textArea.value = text;\n        textArea.focus();\n        textArea.select();\n        activeDocument.execCommand('copy');\n        if (isHTMLElement(activeElement)) {\n            activeElement.focus();\n        }\n        textArea.remove();\n    }\n    async readText(type) {\n        // With type: only in-memory is supported\n        if (type) {\n            return this.mapTextToType.get(type) || '';\n        }\n        // Guard access to navigator.clipboard with try/catch\n        // as we have seen DOMExceptions in certain browsers\n        // due to security policies.\n        try {\n            return await getActiveWindow().navigator.clipboard.readText();\n        }\n        catch (error) {\n            console.error(error);\n        }\n        return '';\n    }\n    async readFindText() {\n        return this.findText;\n    }\n    async writeFindText(text) {\n        this.findText = text;\n    }\n    static { this.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1000; }\n    async readResources() {\n        // Guard access to navigator.clipboard with try/catch\n        // as we have seen DOMExceptions in certain browsers\n        // due to security policies.\n        try {\n            const items = await getActiveWindow().navigator.clipboard.read();\n            for (const item of items) {\n                if (item.types.includes(`web ${vscodeResourcesMime}`)) {\n                    const blob = await item.getType(`web ${vscodeResourcesMime}`);\n                    const resources = JSON.parse(await blob.text()).map(x => URI.from(x));\n                    return resources;\n                }\n            }\n        }\n        catch (error) {\n            // Noop\n        }\n        const resourcesStateHash = await this.computeResourcesStateHash();\n        if (this.resourcesStateHash !== resourcesStateHash) {\n            this.clearResourcesState(); // state mismatch, resources no longer valid\n        }\n        return this.resources;\n    }\n    async computeResourcesStateHash() {\n        if (this.resources.length === 0) {\n            return undefined; // no resources, no hash needed\n        }\n        // Resources clipboard is managed in-memory only and thus\n        // fails to invalidate when clipboard data is changing.\n        // As such, we compute the hash of the current clipboard\n        // and use that to later validate the resources clipboard.\n        const clipboardText = await this.readText();\n        return hash(clipboardText.substring(0, BrowserClipboardService_1.MAX_RESOURCE_STATE_SOURCE_LENGTH));\n    }\n    clearInternalState() {\n        this.clearResourcesState();\n    }\n    clearResourcesState() {\n        this.resources = [];\n        this.resourcesStateHash = undefined;\n    }\n};\nBrowserClipboardService = BrowserClipboardService_1 = __decorate([\n    __param(0, ILayoutService),\n    __param(1, ILogService)\n], BrowserClipboardService);\nexport { BrowserClipboardService };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}